DAY 1 html+css

elements 元素,要素，基本组成部分

APP 是通过自身 webview 插件来实现直接打开网站的（插件是 webkit 内核）

plugin 插件

format 格式化

document 文件

region 区域，地区

debug 调试代码

extensions 扩展

browser 浏览器

open in browser 将 HTML 页面在浏览器打开

ATOM 主题

VScode-icons 文件图标样式

auto save 自动保存

font size 修改代码字体大小

word wrap 代码自动换行

render whitespace 空格的渲染方式

tab size 代码缩进

default 默认的

tab 缩进

shift+tap 反向缩进

！自动生成一套 HTML 代码

vscode 直接打命令就可以生成语句

alt+b 可以直接在浏览器打开

CTRL+.就是改变输入法中英文快捷键

ul 前面是小黑点用 LI 标签

ol 是有顺序的

单标签的形式

src 是 source 的缩写，源的意思

img 用于显示图片无结束标签，有属性用于关联图片

**嵌套关系**，将父元素子元素，ul 是 li 的父元素

li 是 div 的父元素，div 又是 3 个 span 的父元素

相同之间是兄弟元素，相同层级之间的称呼。

img src="图片地址" alt="xxx"alt 代表图片不显示的时候显示的东西

width 宽度，在 body 里的 bgcolor 代表背景颜色
**元素属性**给标签属性 div class="M"代表将 div 进行分类

img 有 src 属性，是给它展示一个图片，将图片地址赋给它即可显示

class、id、title 是所有标签都有的属性。title 属性可以让你指着图标的时候有一个提示语。

meta 元素的 charset 属性

写代码的时候多做注释便于理解与检查

**注释** CTRL+/可以快速形成注释将你所选的代码进行注释。

HTML 常用元素![image-20210715111509355](C:\Users\吴浩森\AppData\Roaming\Typora\typora-user-images\image-20210715111509355.png)

<!--注释 -->

网页结构：

<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>标题</title>   
   < style>
       .main-top{
                  color:red;
       			}
    </style>

</head>

<body>

<div class="main-top">     
<h1>
       <p>你好</p>
       <p>桃子</p>
   </h1>
</div>

</body>

</html>

# DAY 2

## 内容概要

### 1.1 文档声明

111<!DOCTYPE HTML>不能省略以防出现兼容问题

### 1.2HTML 元素

head 后要定义类型《meta charset=“utf-8”》,元素数据，-》meta 元素用于网页的字符编码的基本设置，定义 head 适用于描述数据的数据，指元数据，比如字符编码，网页标题，网页图标。head 里还可以写 title，meta，style 等元素、标签，link 是单标签，可以引入外部 CSS 样式，它也可以设置网站小图标，link rel=“icon” href=“”链接图片；lang 元素，指语言 用法在《！doctype html》后，《html lang=“en/zh-CN”》

body 元素：

 h：定义标题有 1.2.3.4.5.6，h1 一般一个网站才一个有助于搜索引擎搜索

 p：表示段落

 strong：表示加粗，一般通过 CSS 来表示，少用 HTML 标签加粗字体

 img 元素 src="" alt=""

 code 元素 代码可以将代码变成等宽字体

 br 元素 换行元素<br>写在行后面就行

 pre 标签就是空格也保留<字符实体>

 div 可实现分块的功能，基本不用 BR

 hr 元素 分割线 分割线一般不用 hr

 用 div，然后修改样式，div 一般用 line height 来设置高度

 span 也可实现 code 的功能，基本都是通过 span 实现代码的功能

span 默认情况下跟普通文本没什么区别，用于区分特殊文本 span 也是行内元素，可对普通文本进行归类，span class =“new-price”可以做一个分类，类名然后通过 CSS 定义不同的类型。

用 style 可以定义元素样式《style》{。text}class 就是通过点去查找的

div 元素的使用：一般作为其他元素的父容器，把其他元素包住，代表一个整体，用于把网页分割为多个独立的部分

img 元素专门用来显示图片的 单标签 image source img src=“链接” alt“如果不显示的话显示的内容”，图片分本地图片以及网上图片，相对路径以及绝对路径，基本用的都是相对路径 px=picel 像素

a 元素 超链接，网站要有 http 要有协议头，href 超链接

target 属性和 iframe 元素一起用的还有 parent top 可传具体内容 \_self 是自己的意思是默认值\_blank 是空白页

### 字符实体：

用于特殊符号的编写。

 &nbsp 是代表空格

 &lt 小于 &gt 大于的意思要加分号 。相关资料在 ziliao 里边

code：

### 相关单词

img=image 显示图片

src:图片路径（相对路径、绝对路径）

char 指字符

lang 是 language 的缩写

字符编码有很多格式 一般用 utf-8

href :hyper reference 指的是超链接

p 指 paragraphs 指段落

h 是标题的缩写

width 宽度 height 高度

px 像素，pixel

document 文本文档记录

solid 实心的意思

### URL、SEO 优化

url 是用于重定向，使其指向某个特定的页面

URL 更具体更完整的语法格式为：
protocol://hostname[:port]/path/[;parameters]?query#fragment
http://www.baidu.com:80/s?wd=ios#page

port（端口号）
一台拥有 IP 地址的主机可以提供许多服务，比如 Web 服务、FTP 服务、SMTP 服务等
主机通过“IP 地址 + 端口号”来区分不同的服务，端口号类似于营业厅的窗口
端口号的范围从 0 到 65535，HTTP 默认端口号是 80，FTP 默认端口号是 21

query
请求参数，提交给服务器的数据

fragment

锚点位置

用 A 元素进行跳转 day3 有

H 元素有助于搜索引擎优化（seo=search engine optimization）,有助于关键字排名

### 快捷键

CTRL+enter 是直接移到下一行

alt+shift+向下健是复制当前行向下复制

CTRL+f 是搜索

**注释** CTRL+/可以快速形成注释将你所选的代码进行注释。

alt+b 可以直接在浏览器打开

CTRL+.就是改变输入法中英文快捷键

点住 alt 可以单击一次选择多个内容，alt 加 shift 然后鼠标拖动可以快速选择多个行

alt shift f 快捷键格式化分开，是文本看起来好看一点

### 练习

百度文库人物介绍，新闻，图片,a meta

# DAY 3

## 内容概要

所有的标签基本上都可以相互转化

## CSS

CSS 的全称是 Cascading Style Sheets，层叠样式表

按照 CSS 属性的具体用途，大致可以分类为
文本：color、direction、letter-spacing、word-spacing、line-height、text-align、text-indent、text-transform、text-decoration、white-space
字体：font、font-family、font-style、font-size、font-variant、font-weight
背景：background、background-color、background-image、background-repeat、background-attachment、background-position
盒子模型：width、height、border、margin、padding
列表：list-style
表格：border-collapse
显示：display、visibility、overflow、opacity、filter
定位： vertical-align、position、left、top、right、bottom、float、clear

css 属性名一般写成小写

- All Standards and Drafts 所有标准和草稿
- 由于浏览器版本、CSS 版本等问题，有些 CSS 属性是无法使用的
  可以到https://caniuse.com/查询CSS属性的可用性

前面写属性名后面写属性值

CSS 应用到元素的三种方法：1.内联样式（inline style）

2.文档样式表（document style sheet）、内嵌样式表（embed style sheet）

3.外部样式表（external style sheet）

4.选择器什么是 CSS 选择器

按照一定的规则选出符合条件的元素，为之添加 CSS 样式

选择器的种类繁多，大概可以这么归类
通用选择器（universal selector）
元素选择器（type selectors）
类选择器（class selectors）
id 选择器（id selectors）
属性选择器（attribute selectors）
组合（combinators）
伪类（pseudo-classes）
伪元素（pseudo-elements）

## 类命名原则

一个元素可以有多个 class 值，每个 class 之间用空格隔开
class 值如果由多个单词组成，单词之间可以用中划线-、下划线\_连接，也可以使用驼峰标识
最好不要用标签名作为 class 值

![image-20210717164446730](你好 桃子.assets/image-20210717164446730.png)

CSS 注释/\* \*/与 HTML 不同

## css 常见属性

color：前景色（文字颜色）

font-size：文字大小

background-color：背景色

width ：宽度

height：高度

## import：

可以在 style 元素或者 CSS 文件中使用@import 导入其他的 CSS 文件

不建议使用@import 导入 CSS 文件，它的效率比 link 元素低

## link 用法

<link rel="stylesheet" href="css" type="css/text">元素的type属性值默认是text/css,将CSS样式文件引入

![image-20210717192722046](你好 桃子.assets/image-20210717192722046.png)

link 元素的 rel 属性不能省略，用来指定文档与链接资源的关系
一般 rel 若确定，相应的 type 也会默认确定，所以可以省略 type
网页图标支持的图片格式是 ico、png，常用大小是 16x16、24x24、32x32（单位：像素）icon（图标）

![image-20210717192620305](你好 桃子.assets/image-20210717192620305.png)

![image-20210717192631270](你好 桃子.assets/image-20210717192631270.png)

# DAY 4

## CSS 文本字体 font 和 text

text-decoration 用于设置文字的装饰线
none：无任何装饰线
可以去除 a 元素默认的下划线
underline：下划线

u、ins 元素默认就是设置了 text-decoration 为 underlineoverline：上划线
line-through：中划线（删除线）

letter-spacing、word-spacing 分别用于设置字母、单词之间的间距
默认是 0，可以设置为负数

text-transform 用于设置文字的大小写转换可以设置以下值
capitalize：将每个单词的首字符变为大写
uppercase：将每个单词的所有字符变为大写
lowercase：将每个单词的所有字符变为小写
none：没有任何影响

text-indent 用于设置第一行内容的缩进，text-indent: 2em; 刚好是缩进 2 个文字，em 相当与一个字体的大小的距离，rem 指的是根元素的字体大小

text-align 可用于设置元素内容在元素中的水平对齐方式常用的值
left：左对齐
right：右对齐
center：正中间显示
justify：两端对齐

font-size 决定文字的大小
常用的设置
具体数值+单位
比如 100px
也可以使用 em 单位：1em 代表 100%，2em 代表 200%，0.5em 代表 50%，谷歌浏览器最小值设置 12px
百分比
基于父元素的 font-size 计算，比如 50%表示等于父元素 font-size 的一半

<img src="你好       桃子.assets/image-20210718121938305.png" alt="image-20210718121938305" style="zoom: 200%;" />

英文在前中文在后，英文用英文

font-weight 用于设置文字的粗细（重量）

100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900：每一个数字表示一个重量
normal：等于 400
bold 粗体：等于 700

font-style 用于设置文字的常规、斜体显示

normal：常规显示
italic：用字体的斜体显示(前提, 是 font-family 这种字体本身是支持斜体)
oblique：文本倾斜显示(让文字倾斜)

em、i、cite、address、var、dfn 等元素的 font-style 默认就是 italic

font-variant 用的较少可以影响小写字母的显示形式
可以设置的值如下
normal：常规显示
small-caps：将小写字母替换为缩小过的大写字母

### line-height

用于设置文本的最小行高

行高可以先简单理解为一行文字所占据的高度

行高的严格定义是：两行文字基线（baseline）之间的间距

基线（baseline）：与小写字母 x 最底部对齐的线

![image-20210718135851174](你好 桃子.assets/image-20210718135851174.png)

注意区分 height 和 line-height 的区别
height：元素的整体高度
line-height：元素中每一行文字所占据的高度

应用实例：假设 div 中只有一行文字，如何让这行文字在 div 内部垂直居中
让 line-height 等同于 height

![image-20210718140111335](你好 桃子.assets/image-20210718140111335.png)

font 是一个缩写属性

font-style、font-variant、font-weight 可以随意调换顺序，也可以省略
/**line-height 可以省略，如果不省略，必须跟在 font-size 后面**
font-size、font-family 不可以调换顺序，不可以省略

## css 选择器

类选择器.，id 选择器#，元素选择器，统配选择器，，属性选择器【】，HTML 里边引号和大小写基本不区分。

p 里面不能带 div,

后代选择器

是直接加个空格然后选择类，类似于 div span 意思激素 div 里的 span

![image-20210718163621390](你好 桃子.assets/image-20210718163621390.png)

用>号，子代选择器也可以直接用类来写， p 里面不能带 div,

div 元素后面**紧挨着**的 p 元素（且 div、p 元素必须是兄弟关系）

![image-20210718165132166](你好 桃子.assets/image-20210718165132166.png)

相邻兄弟选择器：div+p

全兄弟选择器：div 元素**后面**的 p 元素（且 div、p 元素必须是兄弟关系）

div~p

选择器组

## 相关词语

| indent                |                       |
| --------------------- | --------------------- |
| 英[ɪnˈdent , ˈɪndent] | 美[ɪnˈdent , ˈɪndent] |

| v.  | 将(印刷或书写的行)缩进，缩格，缩排; |
| --- | ----------------------------------- |
|     |                                     |

###

| transform | 英[trænsˈfɔːm] | 美[trænsˈfɔːrm] |
| --------- | -------------- | --------------- |
|           |                |                 |

| v.  | 使改变形态; 使改变外观(或性质); 使改观; |
| --- | --------------------------------------- |
|     |                                         |

| align | 英[əˈlaɪn] | 美[əˈlaɪn] |
| ----- | ---------- | ---------- |
|       |            |            |

| v.  | 排整齐; 校准; (尤指)使成一条直线; 使一致; |
| --- | ----------------------------------------- |
|     |                                           |

| decoration      |                 |
| --------------- | --------------- |
| 英[ˌdekəˈreɪʃn] | 美[ˌdekəˈreɪʃn] |

| n.  | 装饰品; 装饰图案; 装饰风格; |
| --- | --------------------------- |
|     |                             |

# DAY 5

## 内容概述

## 伪类和伪元素

pseudo-classes 伪类

dynamic pseudo -classes 动态伪类

target pseudo-classes 目标为类 直接用：号

language pseudo-classes 语言伪类

UI element states pseudo-classes 元素状态伪类

structural pseudo-classes 结构伪类

negation pseudo-classes 否定伪类

伪类要注意顺序

a:target 代表交集 a :target 空格 代表后代选择器，一般伪类前不加元素， a 的#后面每一个要是不同的才会显示不同的状态

### 结构伪类

:first-child，等同于:nth-child(1)
:last-child，等同于:nth-last-child(1)
:first-of-type，等同于:nth-of-type(1)
:last-of-type，等同于:nth-last-of-type(1)
:only-child，是父元素中唯一的子元素
:only-of-type，是父元素中唯一的这种类型的子元素
:root，根元素，就是 HTML 元素两个相同

:empty 选中空元素，设置高度，背景颜色， 当元素为空的时候，才有效果

## Emmet 语法

p{文字内容$}\*8 即生成 8 个 p

dib>p\*x,即在 div 下面生成 x 个 p 元素。

dib 等于 display ：inline—block

## css'特性

child：孩子的意思

nth：指第 N 项 nth-child 表示选中第几个子类

### 伪元素 pseudo-element

常用的伪元素有
:first-line、::first-line
:first-letter、::first-letter ，前面可以加元素，第一个字母设置
:before、::before
:after、::after
为了区分伪元素和伪类，建议伪元素使用 2 个冒号，比如::first-line 伪元素会在前面多一个元素的

### 继承

inherited from 继承

如果自己本身有设置就不会继承样式里的属性

有些属性会继承有些不会

widsth:inherit;即可强制继承包裹他的属性

css 继承的是计算值，例如 0.5em 继承过来的就是 30px

### 层叠

后面写的属性会层叠前面的属性

当选择器不同要看选择器权重，以此来显示不同的样式

按照经验，为了方便比较 CSS 属性的优先级，可以给 CSS 属性所处的环境定义一个权值（权重）
!important：10000
内联样式：1000
id 选择器：100
类选择器、属性选择器、伪类：10
元素选择器、伪元素：1
通配符：0

## 相关单词

dynamic 动态

inherited 继承的意思

define：定义

term 期限，任期

# DAY 6

## html 列表元素

margin left 盒子模型

HTML 提供了 3 组常用的用来展示列表的元素
有序列表：ol、li

无序列表：ul、li

定义列表：dl、dt、dd

dl（definition list）
定义列表，直接子元素只能是 dt、dd

dt（definition term）
列表中每一项的项目名

dd（definition description）
列表中每一项的具体描述，是对 dt 的描述、解释、补充
一个 dt 后面一般紧跟着 1 个或者多个 dd

list-style：是 list-style-type、list-style-image、list-style-position 的缩写属性,和 font 相似
list-style: outside url("images/dot.png");
一般最常用的还是设置为 none，去掉 li 元素前面的默认标记 list-style: none;

## HTML 表格元素

table
表格

tr
表格中的行

td
行中的单元格

单元格合并：

合并要领
合并方向是向右、向下
删掉被覆盖掉的 td 元素

## HTML 表单元素

表单常用元素 form input textare select option button label fiedset 两个配合使用设置 legend 说明解释 fieldset 的标题框

readonly：只读

disabled：禁用

checked：默认被选中
只有当 type 为 radio 或 checkbox 时可用

autofocus：当页面加载时，自动聚焦

name：名字
在提交数据给服务器时，可用于区分数据类型

value：取值

form：设置所属的 form 元素（填写 form 元素的 id）
一旦使用了此属性，input 元素即使不写在 form 元素内部，它的数据也能够提交给服务器

select 就可以有选择框，然后里边加入 option 就可以有选项

value 里边是“加值反馈给服务器”

text area 可以输入多行文本。clos 行 rows 列。显示的行数

想要重置按钮可以用 input type=“button” value=重置，必须是 reset 类型

如果是 reset 类型就不用设置 value 值

获取验证码之后要让那个按钮倒数了

### input

type：input 的类型
text：文本输入框（明文输入）
password：文本输入框（密文输入）
radio：单选框就是男女选择框
checkbox：复选框就是可以多选的东西
button：按钮
reset：重置
submit：提交表单数据给服务器
file：文件上传

maxlength：允许输入的最大字数

placeholder：占位文字

male 男 female 女

用 label 就可以选中文本然后选中选项框

### 表单提交

将用户提交的内容提交给服务器

1.将所有 input 包裹到 form 中然后然后再 form 设置服务器地址，input 类型是 submit 提交到，会跳转界面

2。前后端分离，通过 JavaScript 获取所有表单，通过正则表达式经行验证

发送 Ajax 请求将数据传给服务器验证成功后，服务器返回结果，前端解析数据并且决定显示内容（前端渲染，前端路由）

提交表单数据时，浏览器发送的是 http 请求，有 2 种请求方法可以选择
get
在请求 URL 后面以?的形式跟上发给服务器的参数，多个参数之间用&隔开，比如
http://ww.test.com/login?phone=123&password=234&sex=1
由于浏览器和服务器对 URL 长度有限制，因此在 URL 后面附带的参数是有限制的，通常不能超过 1KB

post
发给服务器的参数全部放在请求体中
理论上，post 传递的数据量没有限制（具体还得看服务器的处理能力）

### form 常用属性

action
用于提交表单数据的请求 URL

method
请求方法（get 和 post），默认是 get

target
在什么地方打开 URL（参考 a 元素的 target）

空白页或是自身页面打开相对应的网页

enctype
规定了在向服务器发送表单数据之前如何对数据进行编码
取值有 3 种
application/x-www-form-urlencoded：默认的编码方式
multipart/form-data：**文件上传时必须为这个值**，并且 method 必须是 post
text/plain：普通文本传输

accept-charset：规定表单提交时使用的字符编码

# DAY 7

## 元素类型

### 布尔属性

布尔属性可以没有属性值，写上属性名就代表使用这个属性

常见的布尔属性有 disabled、checked（用于 checkbox 和 radio）、readonly、select multiple（表示多选）size 表示显示多少项、autofocus、selected（）

如果要给布尔属性设值，值就是属性名本身

block-level element 块级元素独占一行

行级元素和其他元素可以在同一行显示 strong 和 span 和 img 也是行内级元素 input

### 块级元素（block-level elements）

独占父元素一行
比如 div、p、pre、h1~h6、ul、ol、li、dl、dt、dd、table、form、article、aside、footer、header、hgroup、main、nav、section、blockquote、hr 等

### 行内级元素（inline-level elements）

多个行内级元素可以在父元素的同一行中显示
比如 a、img、span、strong、code、iframe、label、input、button、canvas、embed、object、 video、audio 等

根据元素的内容（是否浏览器会替换掉元素）类型，HTML 元素可以主要分为 2 大类

### 替换元素（replaced elements）

元素本身没有实际内容，浏览器根据元素的类型和属性，来决定元素的具体显示内容
比如 img、input、iframe、video、embed、canvas、audio、object 等

### 非替换元素（non-replaced elements）

和替换元素相反，元素本身是有实际内容的，浏览器会直接将其内容显示出来，而不需要根据元素类型和属性来判断到底显示什么内容
比如 div、p、pre、h1~h6、ul、ol、li、dl、dt、dd、table、form、article、aside、footer、header、hgroup、main、nav、section、blockquote、hr、a、strong、span、code、label 等

### display 属性

，能修改元素的显示类型，有 4 个常用值
block：让元素显示为块级元素

inline：让元素显示为行内级元素

none：隐藏元素（不占据空间）

inline-block：让元素同时具备行内级、块级元素的特征

display：block none inline 可以直接用 db dn di 显示

先重置样式，ul：{padding：0 margin：0}

## 盒子元素

## 今晚练习

编写一个表单提交

# DAY 8

## 元素类型

## CSS 属性

display 的以下取值，等同于某些 HTML 元素
table：<table>，一个 block-level 表格
inline-table： <table>，一个 inline-level 表格
table-row：<tr>
table-row-group：<tbody>
table-header-group：<thead>
table-footer-group：<tfoot>
table-cell：<td>、<th>，一个单元格
table-caption：<caption>，表格的标题
list-item：<li>

visibility 隐藏元素 hidden 占据空间 display none 隐藏不占空间

overflow 超过，溢出用于控制内容溢出行为

overflow 用于控制内容溢出时的行为
visible：溢出的内容照样可见

hidden：溢出的内容直接裁剪

scroll：溢出的内容被裁剪，但可以通过滚动机制查看
会一直显示滚动条区域，滚动条区域占用的空间属于 width、height

auto：自动根据内容是否溢出来决定是否提供滚动机制

还有 overflow-x、overflow-y 两个属性，可以分别设置水平垂直方向
（建议还是直接使用 overflow，因为目前 overflow-x、overflow-y 还没有成为标准，浏览器可能不支持）

行内元素之间会有空格，解决方法：1.不要有空格，2.注释掉空格，3.body fontsize 设置为 0，其他类 font size 设置成其他 4.利用浮动 float，：left

## 盒子模型

padding 内边距 top right down bottom

padding 1 2 3 4 上右下左

word-break 自动换行

margin 外边距 上下会折叠，左右会叠加，margin 上下传递，如果两个元素重叠，设置子元素就会影响到父元素的 margin top bottom 也会传递

防止传递可以运用 BFC

solid 实线

### 边框

![image-20210726091515419](你好 桃子.assets/image-20210726091515419.png)

none：没有边框，边框颜色、边框宽度会被忽略
dotted：边框是一系列的点
dashed：边框是一条虚线
solid：边框是一条实线
double：边框有两条实线。两条线宽和其中的空白的宽度之和等于 border-width 的值
groove：边框看上去好象是雕刻在画布之内
ridge：和 grove 相反，边框看上去好象是从画布中凸出来
inset：该边框使整个框看上去好象是嵌在画布中
outset：和 inset 相反，该边框使整个框看上去好象是从画布中凸出来

transform rotate 旋转（deg 度数）用 border 实现边框还有形状。

行内元素设置 margin top 和 bottom 没有效果 width height

padding 上下边距变多了不占据位置

以下属性对行内非替换元素的效果比较特殊
padding-top、padding-bottom、不占据空间，上下方向的 border

设置圆角

border-top- radius（水平，垂直）的椭圆的东西，百分比是设置当前的元素的

# DAY 9

## 盒子模型

### outline

外轮廓设置外轮廓，px，可以用来观察其他网站布局，

用 border 容易让原有的内容消失占据空间。

outline 表示元素的外轮廓
不占用空间
默认显示在 border 的外面

outline 相关属性有
outline-width
outline-style：取值跟 border 的样式一样，比如 solid、dotted 等
outline-color
outline：outline-width、outline-style、outline-color 的简写属性，跟 border 用法类似

应用实例
去除 a 元素、input 元素的 focus 轮廓效果

margin：0 auto 可以让元素居中。

box-shadow，水平 垂直，模糊，向外，inset 内阴影，外阴影

阴影可以设置两个直接在上一个下面设置继续 ing 了

### 文字阴影 text-shadow

跟上面设置类似

text-shadow 用法类似于 box-shadow，用于给文字添加阴影效果

text-shadow 同样适用于::first-line、::first-letter

伪类

### box-sizing

盒子大小

padding-bottom 和 border-bottom 都会把盒子高度撑大

box-sizing：content-box；指的是内容的宽高。

border-box 设置的是内容加内边距加边框一起设置了。

### 水平居中

普通文本居中 text-align：center；

行内元素居中 text-align：center；

块级元素居中通过继承上面的 div 的元素的才居中的

是，在自己当前的 div 中居中，想在父元素居中需要在子元素加 margin：0 auto；块级元素居中用 margin： 0 auto。

### margin 的水平居中原理

margin-left：auto 将剩余的空间分给元素左边框，考右

margin-right：auto；将剩余的空间分给元素右边边框，靠左显示

margin：auto；即水平居中

垂直高度设置成 auto 即可令父元素按着子元素大小经行调整

## 背景设置

background-image 用于设置元素的背景图片

会覆盖在 color 上面。默认优先显示第一张，可选两张，第二章直接显示在第一张上面覆盖，有可能会显示第二张图片

background-repeat 平铺效果默认平铺，repeat-x 只会 x 方向平铺

### background-size

：auto 默认图片多大背景就多少

cover 图片全覆盖，图片会拉伸宽高比一样就不会拉伸

contain 对背景图片拉伸只往一个方向拉伸，保持图片宽高比

百分比是占原来块水平宽度的百分之几，写两个值 30 80 就是指宽高比

也可以写 px，设置图片

### background-position

设置位置，宽高比，：center center 两个都在中间，x 轴 y 轴。

默认值是 center

### sprite

减少请求次数，减少服务器压力。

什么是 CSS Sprite
是一种 CSS 图像合成技术，将各种小图片合并到一张图片上，然后利用 CSS 的背景定位来显示对应的图片部分
有人翻译为：CSS 雪碧、CSS 精灵

使用 CSS Sprite 的好处
减少网页的 http 请求数量，加快网页响应速度，减轻服务器压力
减小图片总大小
解决了图片命名的困扰，只需要针对一张集合的图片命名

Sprite 图片制作（雪碧图、精灵图）
方法 1：Photoshop
方法 2：https://www.toptal.com/developers/css/sprite-generator

background-position：0 ，192px

text-indent -999px、就是把那个字移除屏幕外

float：left 就不会影响布局

### 背景居中

设置 min-width 就可以显示拖动跳

设置 background-position 就可以设置一直居中显示

### background-attachment

：scroll 设置背景图片有文字的话只有内容会滚动 fixed

：local 就可以跟着内容一起滚动

：background-attachment 可以设置以下 3 个值
scroll：背景图片跟随元素一起滚动（默认值）

local：背景图片跟随元素以及元素内容一起滚动

fixed：背景图片相对于浏览器窗口固定 ，图片一直古定在那

### background

也是缩写属性，

background 是一系列背景相关属性的简写属性，常用格式是
image position/size repeat attachment color
background-size 可以省略，如果不省略，/background-size 必须紧跟在 background-position 的后面
其他属性也都可以省略，而且顺序任意

### background-image 和 img 的区别

img 是 HTML 元素，background-image 是 css 样式，占

![image-20210728160048461](你好 桃子.assets/image-20210728160048461.png)

今日总结学了 outline，shadow，boxsizing，居中 margin-0 auto

background，

# DAY 10

## 1.cursor 光标

默认：auto 操作系统决定： default 小箭头

pointer 小手 text 一条竖线 none 没有鼠标

## 2.定位

在标准流中，可以使用 margin、padding 对元素进行定位
其中 margin 还可以设置负数

比较明显的缺点是
设置一个元素的 margin 或者 padding，通常会影响到标准流中其他元素的定位效果
不便于实现元素层叠的效果

### position

利用 position 可以对元素进行定位，常用取值有 4 个
static：静态定位 left 那些没有用

relative：相对定位 相对于原来位置，移动不改变原来直接占据的空间

absolute：绝对定位，一层层往上找。找最邻近的祖先元素。应用子绝父相。

fixed：固定定位，相对于整个浏览器，会脱离标准流不占空间，根据视口定位

sub 下标，sup 上标

用于对元素的微调

containing 包含

transform translate 就是相对自己进行位移

justify 平均分，但是对最后一行无效

rotate 旋转

### 脱标元素特点

position:fixed，absolute，float，可以设置宽度高度，宽高默认内容决定的

可以随意设置宽高

宽高默认由内容决定

不再受标准流的约束

不再给父元素汇报宽高数据

### 绝对定位元素（absolutely positioned element）

position 值为 absolute 或者 fixed 的元素

对于绝对定位元素来说
定位参照对象的宽度 = left + right + margin-left + margin-right + 绝对定位元素的实际占用宽度
定位参照对象的高度 = top + bottom + margin-top + margin-bottom + 绝对定位元素的实际占用高度

如果希望绝对定位元素的宽高和定位参照对象一样，可以给绝对定位元素设置以下属性
left: 0、right: 0、top: 0、bottom: 0、margin:0

如果希望绝对定位元素在定位参照对象中居中显示，可以给绝对定位元素设置以下属性
left: 0、right: 0、top: 0、bottom: 0、margin: auto
另外，还得设置具体的宽高值（宽高小于定位参照对象的宽高）

| \*\* \*\*           | **脱离标准流** | **定位元素** | **绝对定位元素** | **定位参照对象**                                                 |
| ------------------- | -------------- | ------------ | ---------------- | ---------------------------------------------------------------- |
| static – 静态定位   | ×              | ×            | ×                | ×                                                                |
| relative – 相对定位 | ×              | √            | ×                | 元素自己原来的位置                                               |
| absolute – 绝对定位 | √              | √            | √                | 最邻近的定位祖先元素（如果找不到这样的祖先元素，参照对象是视口） |
| fixed – 固定定位    | √              | √            | √                | 视口                                                             |

### 元素层叠：

一般是后面的元素盖着前面的元素，若想让前面的元素盖着后面的元素，用 z-index，z-index 属性用来设置定位元素的层叠顺序（仅对定位元素有效）
取值可以是正整数、负整数、0。

比较原则
如果是兄弟关系
z-index 越大，层叠在越上面
z-index 相等，写在后面的那个元素层叠在上面

如果不是兄弟关系
各自从元素自己以及祖先元素中，找出最邻近的 2 个定位元素进行比较
而且这 2 个定位元素必须有设置 z-index 的具体数值

## 3.浮动

练习 12 对绝对定位进行练习

、

# DAAY 11

## 浮动 float

在 CSS 中，有 3 种常用的方法对元素进行定位、布局
normal flow：标准流、常规流、文档流

absolute positioning：绝对定位

float：浮动

绝对定位、浮动都会让元素脱离标准流，以达到灵活布局的效果

元素一旦浮动后
脱离标准流
朝着向左或向右方向移动，直到自己的边界紧贴着包含块（一般是父元素）或者其他浮动元素的边界为止

定位元素会层叠在浮动元素上面

浮动元素不能与行内级内容层叠，行内级内容将会被浮动元素推出
比如行内级元素、inline-block 元素、块级元素的文字内容，浮动元素与 inline-block 元素会产生冲突，所以去除 inline-block 就可以

浮动会触发 BFC 机制 ，就可以设置字环绕图片的效果，如果文字挤占第一行需要再提前图片在文中位置，即可实现图文环绕。

### 规则三，

行内级元素、inline-block 元素浮动后，其顶部将与所在行的顶部对齐

浮动元素不会直接浮动到最顶层，一般都只是浮动到当前行的最左边

### 规则 4

如果元素是向左（右）浮动，浮动元素的左（右）边界不能超出包含块的左（右）边界

### 规则 5

浮动元素之间不能层叠
如果一个元素浮动，另一个浮动元素已经在那个位置了，后浮动的元素将紧贴着前一个浮动元素（左浮找左浮，右浮找右浮）
如果水平方向剩余的空间不够显示浮动元素，浮动元素将向下移动，直到有充足的空间为止

### 规则 6

浮动元素的顶端不能超过包含块的顶端，也**不能超过之前所有浮动元素的顶端**

### 浮动常用的场景

解决行内级元素、inline-block 元素的水平间隙问题

最后一个 margin 元素的设置，设置 margin 负值。

## transform

translate 位置

scale 缩放

rotate 旋转

skew 斜体

transition transform 指的是发生形变的时候的效果以及动画时间

transform-origin 设置原点

## vertical-align 垂直对齐

层叠关系

- 标准元素: 标准流中的元素是不存在层叠
- 定位元素: 定位元素会层叠到标准流元素的上面
  - 定位元素之间可以 z-index
  - 前提: 必须是定位元素 - 非 static
- 浮动元素: float: left/right

标准元素 -> 浮动元素 -> 定位元素

问题: 在进行布局时, 同一行多个元素摆放后, 设置 margin-right 让他们之间产生间距, 那么最有一个元素设置的 margin-right 总是多余:

- 解决办法一: 每一行的最后一个元素, 总是加一个 class, 通过类选择器去除这个 margin-right
- 解决办法二: 通过伪类选择器
  - 兼容性问题
- 解决办法三:
  - .container 固定的宽度>.wrap + 负 margin>很多的 item
  - 最优解

面膜口红眼霜精华卸妆

面膜口红眼霜精华卸妆

# DAY 12

考拉实例搭建考拉海购

分区，如果边框重合，用 margin-right -px 还有 margin-bottom-px 即可解决边框重叠问题。

也可以先添加 bottom 和 right，最后在顶部和左边加上边框 item 布局两种方

## 浮动存在的问题

由于浮动元素脱离了标准流，变成了脱标元素，所以不再向父元素汇报高度

父元素计算总高度时，就不会计算浮动子元素的高度，导致了高度坍塌的问题

解决父元素高度坍塌问题的过程，一般叫做清浮动（清理浮动、清除浮动）

清浮动的目的是
让父元素计算总高度的时候，把浮动子元素的高度算进去

给父元素设置固定高度
扩展性不好（不推荐）

在父元素最后增加一个空的块级子元素，并且让它设置 clear: both
会增加很多无意义的空标签，维护麻烦
违反了结构与样式分离的原则（不推荐）

在父元素最后增加一个 br 标签：<br clear="all">
会增加很多无意义的空标签，维护麻烦
违反了结构与样式分离的原则（不推荐）

## 清除浮动的方法

![image-20210731165101352](你好 桃子.assets/image-20210731165101352.png)

给当前块级伪元素加一个 clear：both 如上图 ，用的多的直接给代码加上类，然后用我们准备好的伪元素的类进行赋值，即可解决样式分离的，清楚浮动，将我们所要放到浮动元素的下边的东西放到下边

div class“clear-fix”增加一个空的块级元素

clear：both

br clear all 两个元素都要在父元素里面，且都在最后

![image-20210801121621350](你好 桃子.assets/image-20210801121621350.png)

## transform

CSS transform 属性允许你旋转，缩放，倾斜或平移给定元素。
Transform 是形变的意思，transformer 就是变形金刚
常见的函数 transform function 有：
平移：translate(x, y)
缩放：scale(x, y)
旋转：rotate(deg)
倾斜：skew(deg, deg)
通过上面的几个函数，我们可以改变某个元素的形变

平移：translate(x, y)
值个数
一个值时，设置 x 轴上的位移
二个值时，设置 x 轴和 y 轴上的位移

**两个值的话不需要加逗号直接写就行了**

值类型：
数字：100px
百分比：参照元素本身（ refer to the size of bounding box ）

缩放：scale(x, y)
值个数
一个值时，设置 x 轴和 y 轴相同的缩放
二个值时，设置 x 轴和 y 轴上的缩放
值类型：
数字：
1：保持不变
2：放大一倍
0.5：缩小一半
百分比：不支持百分比

transform-origin：变形的原点
一个值：
设置 x 轴的原点
两个值：
设置 x 轴和 y 轴的原点
必须是<length>，<percentage>，或 left, center, right, top, bottom 关键字中的一个
left, center, right, top, bottom 关键字
length：从左上角开始计算
百分比：参考元素本身大小

旋转：rotate(deg)
值个数
一个值时，表示旋转的角度
值类型：
deg：旋转的角度
正数为顺时针
负数为逆时针
注意：旋转的原点受 transform-origin 的影响

旋转：skew(x, y)
值个数
一个值时，表示 x 轴上的倾斜
二个值时，表示 x 轴和 y 轴上的倾斜
值类型：
deg：旋转的角度
正数为顺时针
负数为逆时针
注意：旋转的原点受 transform-origin 的影响

## 过渡动画 transition

transition CSS 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性。
transition-property：指定应用过渡属性的名称
可以写 all 表示所有可动画的属性
属性是否支持动画查看文档
transition-duration：指定过渡动画所需的时间
单位可以是秒（s）或毫秒（ms）
transition-timing-function：指定动画的变化曲线
https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function
transition-delay：指定过渡动画执行之前的等待时间

transition：transform 1s ease 指的是发生位移的时候位移的时间以及效果

## vertical-align 对齐方式

div 默认都是基线对齐可参考 12 11 .

middle 中线对齐，x 高度的一半对齐

top 顶部对齐

bottom 底部对齐即可去除底边的微小像素是根据内容的行盒对齐的

# DAY13

考拉案例

warp

要想图片居中 ，样式中 img 要设 align 要设置，middle，且还需要 fontsize 设置为 0

用这种方法容易出现问题，影响布局，最好在样式设置为 position，设置成 relative，top50%，然后 transform：translate（）这 0，59%样既可将图片完美居中。

模糊效果：高斯模糊-毛玻璃效果

category 分类的意思

linear-gradient 线性渐变，在 background 中设置角度，进行颜色渐变的设计，向上为 0 角度（deg，color1，color2）

内容底部加一个边线，可以加多一个 div 是 border-bottom 占据整行

swipe 轮播图，想把图片放到 div 里边需要先移动自身的一半后移动 div 的一半

transform 对行内元素无效

当设置一个块级元素是使用相对定位，必须设置 宽度高度否者不会显示，父相子绝

filter 过滤，滤镜，要加背景图片才可以用于做模糊效果的 filter：blur（9px）

blur 可以运用成高斯模糊

rgb 可以做模糊效果

z -index：-1 就可以将绝对定位的东西，放到下一层使得我们新加入的字可以显示出来

A 元素里边放了 img 之后如果有 z-index 的话，a 元素的高度不会被 img 撑起来。

# DAY 14

flex 布局

隐藏方式：

1.display：none

2.visibility：hidden

3.opacity:不透明度 1 0，支持动画

css3 HTML5

## HTML5 语义化元素：

nav herder section 》 article aside，用语义化标签减少类的使用

在 HMTL5 之前，我们的网站分布层级通常包括哪些部分呢？
header、nav、main、footer
HTML5 新增了语义化的元素：

111 在 HMTL5 之前，我们的网站分布层级通常包括哪些部分呢？
header、nav、main、footer
HTML5 新增了语义化的元素：
<header：头部元素
<nav：导航元素
<section：定义文档某个区域的元素
<article：内容元素
<aside：侧边栏元素
<footer：尾部元素

## 媒元素

HTML5 增加了对媒体类型的支持（在 HTML5 之前是通过 flash 或者其他插件实现的）：
音频：<audio
视频：<video
HTML <video 元素 用于在 HTML 或者 XHTML 文档中嵌入媒体播放器，用于支持文档内的视频播放。

video 元素常见属性：
src：媒体的来源（测试地址http://vfx.mtime.cn/Video/2019/05/30/mp4/190530103807409887.mp4 ）
controls：增加控制工具栏
autoplay：自动播放，但是存在兼容性问题
muted：静音，增加后不静音并且自动播放会生效
loop：循环播放
source 元素
如果存在兼容性问题，可以将多个视频格式的数据源放到 source 元素中
src：通过 src 指定数据的来源

## audio 属性

HTML audio> 元素用于在文档中表示音频内容。
video> 元素常见属性：
src：媒体的来源（测试地址https://music.163.com/song/media/outer/url?id=33894312.mp3）
controls：增加控制工具栏
autoplay：自动播放，但是存在兼容性问题
muted：静音
loop：循环播放
source>元素
如果存在兼容性问题，可以将多个视频格式的数据源放到 source 元素中
src：通过 src 指定数据的来源

## input 元素扩展

HTML5 对 input 也进行了扩展，在之前我们已经学习过的其中几个属性也是 HTML5 的特性：
placeholder：输入框的占位文字
multiple：多个值
autofocus：最多输入的内容
另外对于 input 的 type 值也有很多扩展：
date
time
number
tel
color
email
等等…

## flex 布局

浮动布局比较麻烦，flex 布局多运用于移动端和 pc 端。flexible 弹性布局

相关 div 开启 flex 布局，flex-container（容器），display：flex

盒子里的子元素每一块东西都叫做 flex items（项目，商品）

flex 布局是目前 web 开发中使用最多的布局方案：
flex 布局（Flexible 布局，弹性布局）
目前特别在移动端用的最多，目前 PC 端也使用越来越多了
两个重要的概念：
开启了 flex 布局的元素叫 flex container
flex container 里面的直接子元素叫做 flex items
**设置 display 属性为 flex 或者 inline-flex 可以成为 flex container**
flex： flex container 以 block-level 形式存在
inline-flex： flex container 以 inline-level 形式存在

## flex 布局模型

![image-20210803214834068](你好 桃子.assets/image-20210803214834068.png)

axis 轴

## 应用在 flex container 上的 CSS 属性

flex-flow

### flex-direction 方向

flex items 默认都是沿着 main axis（主轴）从 main start 开始往 main end 方向排布
flex-direction 决定了 main axis 的方向，有 4 个取值
row（默认值）、row-reverse（反向）、column（列）、column-reverse（列反向）

### flex-wrap（包裹）

flex-wrap 决定了 flex container 是单行还是多行
nowrap（默认）：单行，不换行
wrap：多行  
wrap-reverse（反转）：多行（对比 wrap，cross start 与 cross end 相反）交叉轴反转

**flex-flow** 是 flex-direction || flex-wrap 的简写
可以省略，顺序任意

### justify-content

justify-content(使内容齐行) 决定了 flex items 在 main axis 上的对齐方式
flex-start（默认值）：与 main start 对齐
flex-end：与 main end 对齐
center：居中对齐
space-between：
flex items 之间的距离相等
与 main start、main end 两端对齐
space-evenly：
flex items 之间的距离相等
flex items 与 main start、main end 之间的距离 等于 flex items 之间的距离
space-around：
flex items 之间的距离相等
flex items 与 main start、main end 之间的距离是 flex items 之间距离的一半

### align-items

align-items 决定了 flex items 在 cross axis 上的对齐方式
normal：在弹性布局中，效果和 stretch 一样
stretch：当 flex items 在 cross axis 方向的 size 为 auto 时，会自动拉伸至填充 flex container
flex-start：与 cross start 对齐
flex-end：与 cross end 对齐
center：居中对齐
baseline：与基准线对齐，文本的基线，都是第一行的基线

### align-content

align-content 决定了多行 flex items 在 cross axis 上的对齐方式，用法与 justify-content 类似
stretch（默认值）：与 align-items 的 stretch 类似
flex-start：与 cross start 对齐
flex-end：与 cross end 对齐
center：居中对齐
space-between：
flex items 之间的距离相等
与 cross start、cross end 两端对齐
space-around：
flex items 之间的距离相等
flex items 与 cross start、cross end 之间的距离是 flex items 之间距离的**一半**
space-evenly：
flex items 之间的距离相等
flex items 与 cross start、cross end 之间的距离 等于 flex items 之间的距离

## 应用在 flex items 上的 CSS 属性

## flex

flex 是 flex-grow || flex-shrink || flex-basis 的简写,flex 属性可以指定 1 个，2 个或 3 个值。
单值语法: 值必须为以下其中之一:
一个无单位数(<number>): 它会被当作<flex-grow>的值。
一个有效的宽度(width)值: 它会被当作 <flex-basis>的值。
关键字 none，auto 或 initial.
双值语法: 第一个值必须为一个无单位数，并且它会被当作 <flex-grow> 的值。
第二个值必须为以下之一：
一个无单位数：它会被当作 <flex-shrink> 的值。
一个有效的宽度值: 它会被当作 <flex-basis> 的值。
三值语法:
第一个值必须为一个无单位数，并且它会被当作 <flex-grow> 的值。
第二个值必须为一个无单位数，并且它会被当作 <flex-shrink> 的值。
第三个值必须为一个有效的宽度值， 并且它会被当作 <flex-basis> 的值。

## flex-grow

flex-grow 决定了 flex items 如何扩展
可以设置任意非负数字（正小数、正整数、0），默认值是 0
当 flex container 在 main axis 方向上有剩余 size 时，flex-grow 属性才会有效
如果所有 flex items 的 flex-grow 总和 sum 超过 1，每个 flex item 扩展的 size 为，**1，2，1 分成 4 分**
flex container 的剩余 size _ flex-grow / sum
如果所有 flex items 的 flex-grow 总和不超过 1，每个 flex item 扩展的 size 为
flex container 的\*\*剩余 size _ flex-grow\*\*

flex items 扩展后的最终 size 不能超过 max-width\max-height

### flex-basis

flex-basis 用来设置 flex items 在 main axis 方向上的 base size
auto（默认值）、具体的宽度数值（100px）

决定 flex items 最终 base size 的因素，从优先级高到低
max-width\max-height\min-width\min-height
flex-basis
width\height
内容本身的 size

### flex-shrink（收缩）

flex-shrink 决定了 flex items 如何收缩默认会收缩
可以设置任意非负数字（正小数、正整数、0），默认值是 1
当 flex items 在 main axis 方向上超过了 flex container 的 size，flex-shrink 属性才会有效
如果所有 flex items 的 flex-shrink 总和超过 1，每个 flex item 收缩的 size 为
flex items 超出 flex container 的 size _ 收缩比例 / 所有 flex items 的收缩比例之和
如果所有 flex items 的 flex-shrink 总和 sum 不超过 1，每个 flex item 收缩的 size 为
flex items 超出 flex container 的 size _ sum _ 收缩比例 / 所有 flex items 的收缩比例之和
\*\*收缩比例 = flex-shrink _ flex item 的 base size\*\*
base size 就是 flex item 放入 flex container 之前的 size

flex items 收缩后的最终 size 不能小于 min-width\min-height

### order

order 决定了 flex items 的排布顺序
可以设置任意整数（正整数、负整数、0），值越小就越排在前面
默认值是 0

## align-self

flex items 可以通过 align-self 覆盖 flex container 设置的 align-items
auto（默认值）：遵从 flex container 的 align-items 设置
stretch、flex-start、flex-end、center、baseline，效果跟 align-items 一致

在子元素设置可以覆盖父元素的 align-item

# DAY 15

## 网络字体

@font-face 可以让网页支持网络字体(Web Font)，不再局限于系统自带的字体

常见的字体种类
TrueType 字体：拓展名是 .ttf
OpenType 字体：拓展名是 .ttf、.otf，建立在 TrueType 字体之上
Embedded OpenType 字体：拓展名是 .eot，OpenType 字体的压缩版
SVG 字体：拓展名是 .svg、 .svgz
web 开放字体：拓展名是 .woff，建立在 TrueType 字体之上

并不是所有浏览器都支持以上字体，使用时要多加测试

字体下载：https://fonts.google.com/

## 字体图标

思考：字体可以设计成各式各样的形状，那么能不能把字体直接设计成图标的样子呢？
当然可以，这个就叫做字体图标。
字体图标的好处：
放大不会失真
可以任意切换颜色
用到很多个图标时，文件相对图片较小
字体图标的使用：
登录阿里 icons（https://www.iconfont.cn/）
选择自己要用的图标，添加到项目
下载代码，并且拷贝到项目中
通过 link 引入 iconfont.css 文件
使用字体图标：

## 动画补充关键帧动画

之前我们学习了 transition 来进行过渡动画，但是过渡动画只能控制首尾两个值：
从关键帧动画的角度相当于只是定义了两帧的状态：第一帧和最后一帧。
如果我们希望可以有更多状态的变化，可以直接使用关键帧动画。
关键帧动画使用@keyframes 来定义多个变化状态，并且使用 animation-name 来声明匹配： 1.使用 @keyframes（关键帧动画）创建一个规则

2. @keyframes 中使用百分比定义各个阶段的样式

3. 通过 animation（动画）将动画添加到属性上
   另外，也可以使用 from 和 to 关键字：
   from 相当于 0%
   to 相当于 100%

## animation 属性

CSS animation 属性是 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的一个简写属性形式。
animation-name：指定执行哪一个关键帧动画
animation-duration：指定动画的持续时间
animation-timing-function：指定动画的变化曲线
animation-delay：指定延迟执行的时间
animation-iteration-count：指定动画执行的次数，执行 infinite 表示无限动画
animation-direction：指定方向，常用值 normal 和 reverse
animation-fill-mode：执行动画最后保留哪一个值
none：回到没有执行动画的位置
forwards：动画最后一帧的位置
backwards：动画第一帧的位置
animation-play-state：指定动画运行或者暂停（在 JavaScript 中使用，用于暂停动画）

## 3d 动画

CSS 实现 3D：
transform-style: preserve-3d
perspective

JS 实现 3D 的库：
three.js

3D 效果要在父元素设置 perspective 视距

.item.item$\*4 既可以建 4 个 div 且包含两个类，item 和 item1 2 3 4

## 浏览器前缀

## 移动端视频

### 视口大小

视口大小：viewport

![image-20210804142241574](你好 桃子.assets/image-20210804142241574.png)
移动端默认视口大小是 980px，所有的元素在移动端没有设置视口的情况下都会被缩小
width：设置视口的大小
initial-scale：设置缩放的比例

### rem

px 像素

em 相对于父元素字体大小，也可以设置宽高，相对于字体大小的宽高的倍数，一般先看自己是否有设置 font-size，若没有就设置父元素的 font-size，然后乘相对应的倍数

%，用于不同场景不同，用于字体中相对于父元素的百分比 ，不同的元素多去查询文档看看他们是相对于谁的

rem：root em 相当于根元素的字体大小即 HTML 的的 font-size

### rem 移动端适配

将所有需要适配的图片元素统一使用 rem 适配

1.使用媒体查询@media screen and（min-width：320px）

{

 html{font-size：10px；修改 min-width 以及 font-size 就可以适配其他手机

 }

}

2.通过 js 动态计算设置 HTML 的 font-size（最优方案）

3。动态计算 rem 值

方法一：利用 vscode 的插件快速转化
插件：px to rem
快捷键：alt+z

方法二：利用 postcss-pxtorem(最优方案)

方法三：利用 less、sass、stylus 的计算能力

Less 是一种 CSS 预处理器，对 CSS 进行了扩展
VSCode 的 Less 插件：Easy LESS
Less 学习：
Less 变量的定义
Less 代码编写格式
Less 的加减乘除运算

## 文字处理

## 总结回顾 HTML 和 css

图片的使用：img 元素：是网站重要组成部分，不能使用精灵图。

background 元素：装饰，先加载 css-》url，使用精灵图：background-position

icon font 字体图标：字体图标放大时不会失真

### 文字换行处理

文字省略号的显示

![image-20210804135835903](你好 桃子.assets/image-20210804135835903.png)

1. display: -webkit-box;
2.  padding: 0 30px 0 0;
3.  box-sizing: border-box;
4.  font-weight: 700;
5.  overflow: hidden;
6.  text-overflow: ellipsis;
7.  word-break: break-all;
8.  -webkit-line-clamp: 2;
9.  -webkit-box-orient: vertical;

这样才可以显示两行，不能设置高度，用两行的内容撑起来

# DAY 16

网页制作：

1.引入 css，包括样式重置，以及常用样式引入

2.设置 favicon 网页图标，link：favicon

ul,li 是块级元素要全部设置成浮动才不会被撑开

i 是行内级元素，块级元素才可以设置宽高

# DAY 17javascript

完成了购物测样式以及导航栏分类

## js 学习

1.js 一般写在 HTML 之后

2.js 的注释：1//两缸 单行注释，2js 也支持/_ 多行注释 _/跟 css 的注释一样，HTML 的注释为<--! -->,3 文档注释/\*\* _这是一个测试函数 _/ 后面再加一个函数，这样子别人调用函数的时候就可以看见所选函数注释。

变量和数组使用前最好使用初始化

## 3.浏览器的交互方式

![image-20210806224854410](你好 桃子.assets/image-20210806224854410.png)

![image-20210806225109909](你好 桃子.assets/image-20210806225109909.png)

输入后浏览器会返回一个值出现在 console 中

# DAY 18

## 1.变量的定义方式

在变量面前加一个 var 即可定义变量

var 变量名=变量值

文本要加双引号，加了双引号就变文本了，不是变量

1.var number =数字

number=“new”可以先定义后赋值，也可以定义和赋值同时然后给变量重新赋值。

console.log(num1\*num2)

2.var message = "hello JavaScript"

3.同时定义多个变量，var num1, num2, num3,编程习惯，运算符左右最好加个空格

## 2.变量命名规则

第一个字符是字母或者\_或者$

其他字符可以是字母下划线美元符号或数字

不能使用关键字和保留字命名：关键字 相类似与 var，有特殊含义的关键字不能使用，保留字是有可能会变成关键字。

## 3.代码书写规范

1.多个单词使用驼峰标识

fistName,首字母小写，第二个首字母大写，后面的首字母都大写，

2，尽量做到简明知意，不用拼音

3，编程习惯，运算符左右最好加个空格

4，一条语句结束后面加；

5，函数和（）之间不加空格

## 4.数值交换

1.利用临时变量 temp

num1=100

num2=200

num1=temp

num1=num2

num2=tem

现在要交换数值

2.利用加减法使用，不引用临时变量

num1=num1+num2

num2=num1-num2

num1= num1-num2

## 5.数据类型与变量存储

typeof 操作符可以查询数据类型

1.“”里面的东西叫字符串数据，string 字符串型

2.数字叫做数字类型，number

0x 表示 16 进制，0o 表示 8 进制，0b 表示 2 进制，后面跟数字就可以了

3.boolean 布尔型

以上 3 中基本数据类型都在栈空间（stack）存储，引用类型就保存在堆空间里边

– 数值型(数字类型/数值类型)（Number）

Number 类型也叫 数字类型或数值类型
数字的表示方法：十进制（掌握）、十六进制、二进制、八进制（了解）
数字表示的范围：
最小值：Number.MIN_VALUE，这个值为： 5e-324
最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308
NaN，即非数值（Not a Number）是一个特殊的数值，JS 中当对数值进行计算时没有结果返回，则返回 NaN。
isNaN，用于判断是否不是一个数字。不是数字返回 true，是数字返回 false。

– 字符串型（String）

字符串类型：String
字符串类型，用于表示一段文字.
比如人的姓名：coderwhy。地址：广州市。简介：认真是一种可怕的力量。
字符串的表示可以使用单引号也可以使用双引号。

转义字符：掌握 \’\” \t \n 四个的用法，一个\加上一个字母，\t 表示 tab 键
![image-20210807155556399](你好 桃子.assets/image-20210807155556399.png)

获取字符串的长度：.length 属性，console（name.length）,即可让控制器返回字符串长度

– 布尔型（Boolean）

布尔类型用于表示真假：
比如是否毕业. 是否有身份证. 是否购买车票. 是否成年人.
两个取值: true/false

– 空类型（Null）

– 未定义型（Undefined）

Undefined 类型只有一个值：undefined
在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined

typeof 对没有初始化和没有声明的变量都会返回 undefined

值得话是浅颜色，变量类型是深颜色

Null 类型也是只有一个值：null
通常当一个对象（Object 类型）不再使用时，可以赋值为 null

Null 和 Undefined 的关系：
undefined 值实际上是由 null 值衍生出来的，所以如果比较 undefined 和 null 是否相等，会返回 true
但是转化成数字时，undefined 为 NaN，null 为 0

## 6.数据类型之间的转换

//转换数据类型

![image-20210807161829434](你好 桃子.assets/image-20210807161829434.png)

![image-20210807161843727](你好 桃子.assets/image-20210807161843727.png)

将原来的数据类型转化成想定义的数据类型，对比上图

# DAY 19

convert 转换

## 转换成字符串类型

![image-20210808144328572](你好 桃子.assets/image-20210808144328572.png)

## 转换成布尔类型

通常使用 Boolean()函数将其他类型转成布尔类型:
转换成 false 的五种特殊值**：""（空字符串）、0（包括 0、-0）、undefined、null、NaN；**
如果某个值为 ""（空字符串）、0（包括 0、-0）、undefined、null、NaN 时，那么这个值转换成布尔类型之后的值为 false。
否则，其值为 true。（记住五种特殊值）

![image-20210808144647361](image-20210808144647361.png)

## 运算符

%取余，++自增。--自减

![image-20210808145636755](你好 桃子.assets/image-20210808145636755.png)

例子：num++ + 10 = 110

++num + 10 =111

### 赋值运算符

赋值运算符主要是给某个变量进行赋值
赋值运算符是算术运算符和赋值的一种简便写法.
比如 a = 3; a = a + 1;
第二句可以写成 a += 1;

| **运算符** | **运算规则** | **范例**       | \*\* \*\* |
| ---------- | ------------ | -------------- | --------- |
| =          | 赋值         | a = 5          | 5         |
| +=         | 加后赋值     | a = 5, a += 2  | 7         |
| -=         | 减后赋值     | a = 5, a -= 2  | 3         |
| \*=        | 乘后赋值     | a = 5; a \*= 2 | 10        |
| /=         | 除后赋值     | a = 5; a /= 2  | 2.5       |
| %=         | 取余后赋值   | a = 5; a %= 2  | 1         |

### 关系运算符

比较运算符，又叫关系运算符
它是用来判断两个操作数的大小关系及是否相等关系的
结果是布尔类型(bool): True 或者 False
比较运算符经常用在后面学习的 if/while 语句中
学习 if 语句的使用

| **运算符** | **运算规则** | **范例** | **结果** |
| ---------- | ------------ | -------- | -------- |
| ==         | 相等         | 4 == 3   | false    |
| !=         | 不等于       | 4 != 3   | true     |
| >          | 大于         | 4 > 3    | true     |
| <          | 小于         | 4 < 3    | false    |
| >=         | 大于等于     | 4 >=3    | true     |
| <=         | 小于等于     | 4 <= 3   | false    |

### 全等和全部等

除了==以外，JS 中还提供了===
===表示全等，他和==基本一致，不过==在判断两个值时会进行自动的类型转换，而===不会。
比如”123”==123 会返回 true，而”123”===123 会返回 false；
==会进行隐式转换
除了!=以外，JS 中还提供了!==
!==也不会进行自动类型转换，比如”123”!=123 会返回 false，而”123”!==123 会返回 true；

### 逻辑运算符

逻辑运算符，它是用于将多个条件放在一起进行运算的
逻辑运算符的运算结果也是 Boolean 类型: true/false
逻辑运算符也应用 if/while 的判断句中, 并且是多个条件时会使用到

| **运算符** | **运算规则** | **范例**      | **结果** |
| ---------- | ------------ | ------------- | -------- |
| &&         | 与: 同时为真 | false && True | false    |
| \|\|       | 或: 一个为真 | false or frue | true     |
| !          | 非: 取反     | !false        | true     |

逻辑与补充：（了解）
逻辑与运算符可以应用于任何数据类型，且不一定返回布尔值。
对于非布尔值运算，会先将非布尔值转换为布尔值。
逻辑或补充：（了解）
逻辑或运算符可以应用于任何数据类型，且不一定返回布尔值。
对于非布尔值运算，会先将非布尔值转换为布尔值。

### 优先级

![image-20210808154238826](你好 桃子.assets/image-20210808154238826.png)

### 三元运算符

认识三元表达式：
在很多编程语言中，有三元运算符或者称之为三目运算符。
之所以叫三元是因为整个表达式中有三个元素。
三元表达式是一种 if else 的简便写法。
三元表达式的格式：

表达式 1？ 表达式 2 ： 表达式 3

案例一： m=20，n=30，比较两个数字的大小，获取较大的那个数字
案例二：判断一个人是否是成年人了

![image-20210808160445560](你好 桃子.assets/image-20210808160445560.png)

### switch

switch 是分支结构的一种语句：
它是通过判断表达式的结果是否等于 case 语句的常量，来执行相应的分支体的
与 if 语句不同的是，switch 语句只能做值的相等判断（使用全等运算符 ===），而 if 语句可以做值的范围判断

case 穿透问题：
一条 case 语句结束后，会自动执行下一个 case 的语句
这种现象被称之为 case 穿透
break 关键字
通过在每个 case 的代码块后添加 break 关键字来解决这个问题

案例：陪女朋友过生日的案例（通过 switch 实现）

![image-20210808160951181](你好 桃子.assets/image-20210808160951181.png)

prompt，提示符

# DAY 20

## for 循环（）{}

for 循环是开发中使用最多的循环语句：

![image-20210809150741370](你好 桃子.assets/image-20210809150741370.png)

语句一：初始化表达式：通常会写 var i=1
语句二：条件表达式，用于判断进行条件判断
语句三：自增、减表达式，比如 i++或 i--
练习一: 打印 10 次 Hello World
练习二: 打印 0~99 的数字
练习三: 计算 0~99 的数字和
练习四: 计算 0~99 所有奇数的和
练习五: 计算 0~99 所有奇数的和
练习六: 计算 0~99 所有偶数的和

一般用 ijk、n 当作变量

## 循环的跳转

![image-20210809153827045](你好 桃子.assets/image-20210809153827045.png)

跳过本次循环直接进行下次循环

break 就可以直接结束循环

## 断点调试

在开发中，为了获取一个变量的值，我们可以通过打印到控制台
但是，查看一个变量的变化，我们可以通过断点调试
断点调试也被称为 debug
开启断点调试常见的有两种方式：
方式一：找到自己的源代码，在其中打断点
方式二：在代码中写上 debugger

![image-20210809155039027](你好 桃子.assets/image-20210809155039027.png)

## 数组的使用

JavaScript 中的数组我们可以通过字面量的方式创建：[]
[]中存放一组数据，删除会从最后一个开始删除
虽然 JavaScript 支持在数组中存放不同的数据类型，但是开发中**建议存放相同的类型**
定义数组保存朋友的名字，喜欢的电影等

![image-20210809155401748](你好 桃子.assets/image-20210809155401748.png)

## 常见操作

数组有一个 length 属性，所以可以直接通过 length 获取数组的长度

![image-20210809160145764](你好 桃子.assets/image-20210809160145764.png)

获取数组某个位置的数据：通过索引值
索引值也被称为下标值 index
索引值是从 0 开始的（注意，不是从 1 开始的)
注意：在 JavaScript 中获取一个不存在的索引值，不会报错，结果为 undefined

![image-20210809160211103](你好 桃子.assets/image-20210809160211103.png)

数组还有很多其他的操作方法，我们学习到数组的包装类时再学习

## 遍历

遍历：遍及所有，历经全部的意思，也被称之为迭代。
对数组的每一个元素都访问一次就叫遍历。

![image-20210809160727868](你好 桃子.assets/image-20210809160727868.png)

## 冒泡排序

每一次排序都是将最大的数排到最后面

## 选择排序

每次选择最小的或最大的

![image-20210810163855965](你好 桃子.assets/image-20210810163855965.png)

# DAY 21

## 函数的调用和定义

函数的命名规则，定义，调用

![image-20210810145348005](你好 桃子.assets/image-20210810145348005.png)

## 参数传递

![image-20210810145746495](你好 桃子.assets/image-20210810145746495.png)

![image-20210810145922773](你好 桃子.assets/image-20210810145922773.png)

## 函数返回值

![image-20210810150415700](你好 桃子.assets/image-20210810150415700.png)

一旦插入 return，后续代码就会停止，如果没有返回值，返回值就会返回 undefined

![image-20210810150744647](你好 桃子.assets/image-20210810150744647.png)

## arguments 函数

可以把定义的数组全部都放进去

## 作用域

![image-20210810155618874](你好 桃子.assets/image-20210810155618874.png)

## 函数表达式写法

![image-20210810160423229](你好 桃子.assets/image-20210810160423229.png)

## 立即执行函数写法

匿名函数表达式![image-20210810161350133](你好 桃子.assets/image-20210810161350133.png)

命名函数表达式

![image-20210810161540963](你好 桃子.assets/image-20210810161540963.png)

![image-20210810161608431](你好 桃子.assets/image-20210810161608431.png)

## 值传递

输出 why![image-20210810162210641](你好 桃子.assets/image-20210810162210641.png)

## 引用传递

![image-20210810162509606](你好 桃子.assets/image-20210810162509606.png)

输出 abc 20 30

# DAY 21

## js 优先级

外部引入优先级高于内部写，

## ES6

1.创建类：class name{}，类名习惯性用大写字母

创建实例：var xxx = new name();

类必须使用 new 进行实例化对象，利用 new 调用上面定义的类

2.类 constructor（）方法是类的构造函数（默认方法），用于传输参数，返回实例对象，通过 new 命令生成对象实例时，自动调用该方法，如果没有显示定义，类内部会自动给我们创建一个 constructor（），会接受传递过来的实例，也会返回实例对象。

且构造函数不需要加 function

# DAY 22

类里边创建函数方法，不用加 function，不用加逗号。

![image-20210812153343138](你好 桃子.assets/image-20210812153343138.png)

## 类的继承

继承，class Son extends Father{}，子类使用父类的方法，采用就近原则继承

## super 关键字

可以访问调用对象父类的函数，可以调用父类的构造函数，也可以调用父类的普通函数（super.函数），即可调用父类中的普通函数

![image-20210812155356044](你好 桃子.assets/image-20210812155356044.png)

![image-20210812160131992](你好 桃子.assets/image-20210812160131992.png)

继承父类的函数加上自己的方法需要把 super 写在前面

substract 减去

## 关键学习知识点

es6，promise，this，原型链，作用域，闭包

## 类和对象的三个注意点

![image-20210812162106164](你好 桃子.assets/image-20210812162106164.png)

## 基础回顾

alert 浏览器中弹出警示框

console 浏览器控制台输出信息

prompt 浏览器弹出输入框，用户输入

# DAY 23

前面有（）就代表是函数

## 定义函数

函数定义需要加个 function，在定义函数并且要调用才会执行所定义的函数，函数返回值只能返回一个，如果有多个数需要用数字将数都放入数组中

# DAY 24

尚硅谷 06

![image-20210816095719559](你好 桃子.assets/image-20210816095719559.png)

有 var 就会操作 var，10，20，300，数组和函数是对象型类型

![image-20210816150207704](你好 桃子.assets/image-20210816150207704.png)

因此输出的是 1，22，3，

![image-20210816150625727](你好 桃子.assets/image-20210816150625727.png)

arr 会生成一个新的地址，因此 arr1 还哦是输出 123

![image-20210816151028962](你好 桃子.assets/image-20210816151028962.png)

输出 60 10，20

![image-20210816151125549](你好 桃子.assets/image-20210816151125549.png)

对象数据类型传参，输出 3，4，5，返回值也是返回地址

## 函数预解析

有函数先解析函数再解析 var，解析的时候函数变量名与 var 变量名重名相当于后面的被注释掉了，如果两个都是函数的话前面的函数就会被覆盖，function 函数执行的时候函数内部也需要预解析

![image-20210816154427217](你好 桃子.assets/image-20210816154427217.png)

函数充满后面会把前面覆盖，先把变量定义不赋值，所以

alert（a）

a=0

报错，alert（a） var=0，就会输出 undefined

程序一旦报错后面的程序不会执行

![image-20210816155900859](你好 桃子.assets/image-20210816155900859.png)

打印：function a(){alert(‘我是函数’)}

 f（）{}

![image-20210816160246675](你好 桃子.assets/image-20210816160246675.png)

函数进行数字运算会先转化成数字，然后在进行相加，上述函数就转化成 nan，nan 与谁运算都变成 nan

# DAY 25

## arguments

arguments 函数实参伪数组，arguments.length 用的多

![image-20210817130819845](你好 桃子.assets/image-20210817130819845.png)

arguments.callee 打印出来的就是函数本身，在函数递归调用的时候用得上

## 函数递归调用

![image-20210817133135052](你好 桃子.assets/image-20210817133135052.png)

调用 10 次就停止

![image-20210817151412607](你好 桃子.assets/image-20210817151412607.png)

arguments.callee 打印出来的就是函数本身，在函数递归调用的时候用得上

调用原来函数

## 递归函数求阶乘

![image-20210817151918929](你好 桃子.assets/image-20210817151918929.png)

可以简化代码，但是效率不高，除非不得已能不用就不用

## 对象的三种定义方式

1.用的比较多

![image-20210817153707503](你好 桃子.assets/image-20210817153707503.png)

2.

![image-20210817154520587](你好 桃子.assets/image-20210817154520587.png)

构造函数 new

3.

![image-20210817154819736](你好 桃子.assets/image-20210817154819736.png)

## 对象的操作和遍历

操作：增删改查

。语法和【】语法

![image-20210817155512894](你好 桃子.assets/image-20210817155512894.png)

【】是通用的语法，但是写起来复杂一点，。语法写起来简单，有些场合无法使用，。后面必须跟合法的属性名才可以，不然会报错

![image-20210817160101511](你好 桃子.assets/image-20210817160101511.png)

加了引号相当于属性值，不加引号相当于变量

删除

![image-20210817160327245](你好 桃子.assets/image-20210817160327245.png)

查找

![image-20210817160410869](你好 桃子.assets/image-20210817160410869.png)

对象的遍历

for in 循环

![image-20210817160709812](你好 桃子.assets/image-20210817160709812.png)

![image-20210817161000584](你好 桃子.assets/image-20210817161000584.png)

![image-20210817161354706](你好 桃子.assets/image-20210817161354706.png)

有的对象遍历不到，因此我们必须 for in 若有对象属性的话

this 的理解

![image-20210817162508634](你好 桃子.assets/image-20210817162508634.png)

# DAY 26

## this 和 window

this![image-20210818143052054](你好 桃子.assets/image-20210818143052054.png)

使用场合

![image-20210818143430648](你好 桃子.assets/image-20210818143430648.png)

对象调用 this 结果

![image-20210818143734409](你好 桃子.assets/image-20210818143734409.png)

函数调用和和方法调用不用的 this

![image-20210818144010709](你好 桃子.assets/image-20210818144010709.png)

## 函数

![image-20210818144201498](你好 桃子.assets/image-20210818144201498.png)

当普通函数和构造函数用的不同情况

![image-20210818144419240](你好 桃子.assets/image-20210818144419240.png)

## new 的作用

### **\*\*new 关键字\*\*\*\*\***\*作用\*\*\*\*

 1、开辟内存空间(堆)

 2、this 指向该内存（让函数内部的 this）

 3、执行函数代码

 4、生成对象实例返回（把空间的地址返回）

## **原型对象**

![image-20210818151528632](你好 桃子.assets/image-20210818151528632.png) 什么是原型对象:

 一个函数对象在定义的时候，伴随它出现的另外一个对象就是原型对象，原型对象是默认是 Object 的实例对象

显示原型对象和隐式原型对象概念

 函数对象身上的 prototype 属性值（显式）

注意：只有函数对象身上才会有 prototype 这个属性

不是函数对象身上没有这个属性

实例化对象身上的**proto**属性值（隐式）

 这两个属性的值是同一个对象，就是我们说的原型对象

#### **原型对象的作用，**

 资源共享 节约内存

## 原型链作用域链

原型对象默认都是 object 生成的

![image-20210818153231915](你好 桃子.assets/image-20210818153231915.png)

## apply 和 call 的使用

任何函数对象都有 apply 和 call 方法

apply 和 call 可以使用第一个参数传对象，让函数或者方法的执行者（this）指向这个对象；

call 和 apply 可以让一个对象执行另外一个对象的方法；

 函数或者方法.apply(对象，【函数的参数】)；

 函数或者方法.call(对象，函数的参数 1，函数的参数 2)；

call 和 apply 干了两件事：

1、调用的时候先把 this 指向改为你指定的第一个参数对象

2、然后再去自动执行使用的方法

d1 是狗狗的方法 obj 是赵丽颖的

![image-20210818154738890](你好 桃子.assets/image-20210818154738890.png)

![image-20210818154830402](你好 桃子.assets/image-20210818154830402.png)

apply 修改内部的 this 指向

## call

![image-20210818154906699](你好 桃子.assets/image-20210818154906699.png)

call 和 apply 使用方法是一样的就是写法不同

## \*\*instanceof\*\*

#### **typeof 应用的场景**

 typeof 值 返回的是数据类型的小写字符串形式

 数字 'number'

 字符串 ‘string’

 布尔 'boolean'

 undefined 'undefined'

 null 'object'

 数组 'object'

 函数 'function'

 对象 'object'

 typeof 可以判定 5 种：

 数字 'number'

 字符串 ‘string’

 布尔 'boolean'

 undefined 'undefined'

 函数 'function'

#### **instanceof 应用的场景**

 instanceof 用来判断一个对象是哪个构造函数的实例用的 A(对象数据) instanceof B（构造函数）

![image-20210819095147708](你好 桃子.assets/image-20210819095147708.png)

专门用来解决判定数组和对象的时候使用

#### **===**

 全等于可以用来判定 null 和 undefined 的时候使用；因为他们两个都是数据类型，但是这数据类型当中只有一个值；

 a === null

 a === undefined

通过 typeof instanceof 以及 === 可以让我们判定 js 当中所有的数据类型

object 是一切对象的祖先

## 一、 **值类型，引用数据类型，堆， 栈**

## **值类型和引用数据类型的概念**

值类型都有啥: 其实就是我们所说的基本数据类型

对象类型都有啥：引用数据类型就是我们所说的对象数据类型、复杂（复合）

### **值类型和引用数据类型与堆栈的关系**

堆空间的释放是靠垃圾回收机制进行的

当程序函数或者整个程序执行完成后，栈里面所有的东西都被释放销毁，堆当中的数据可能还在，只是没有任何的变量指向（引用），那么堆当中的数据就会变成垃圾对象。回收机制会在适当的时候将垃圾对象清理回收；

 如果我们在程序当中需要去删除对象，那么就将这个对象的变量赋值为 null，代表这个对象引用被改变，这个对象也就成了垃圾对象，其实删除对象就是让堆当中的对象数据成为垃圾对象；

 var a = {};

 a 里面存了 {}地址 a 指向了{}这个对象

 a = null; 把 a 的指向断开了；

# DAY 27

## 对象判等，是判断地址地址一样才可以

## 内置 json 对象

主要用于前后端交互

![image-20210819110216433](你好 桃子.assets/image-20210819110216433.png)

![image-20210929173714335](你好 桃子.assets/image-20210929173714335.png)

json 本质是一个对象，通过 JSON。stringify（）转化为 json 串，然后通过 JSON。parse（）转化回来变成对象

## math

![image-20210819110534720](你好 桃子.assets/image-20210819110534720.png)

![image-20210819111052726](你好 桃子.assets/image-20210819111052726.png)sin 跟三角函数相关的都是用弧度，js 中不用 deg![image-20210819141017011](你好 桃子.assets/image-20210819141017011.png)

## Math.random

![image-20210819142308932](你好 桃子.assets/image-20210819142308932.png)

![image-20210819142336263](你好 桃子.assets/image-20210819142336263.png)

![image-20210819142542087](你好 桃子.assets/image-20210819142542087.png)

![image-20210819143351424](你好 桃子.assets/image-20210819143351424.png)

向下取整，取值

## 验证码生成

![image-20210819145932415](你好 桃子.assets/image-20210819145932415.png)

封装函数实现随机验证码

![image-20210819150004567](你好 桃子.assets/image-20210819150004567.png)

![image-20210819150221988](你好 桃子.assets/image-20210819150221988.png)

日期事件和对象

![image-20210819150629209](你好 桃子.assets/image-20210819150629209.png)

![image-20210819150724050](你好 桃子.assets/image-20210819150724050.png)

![image-20210819151026158](你好 桃子.assets/image-20210819151026158.png)

## 包装对象

后面带括号（）证明是函数，【】数组，{}方法，a。b，b 代表的属性，有包装对象就可以调用 a。tostring，只有数字，字符串，布尔值才能调用包装对象

![image-20210819152236287](你好 桃子.assets/image-20210819152236287.png)

## 字符串的方法 es5

函数三要数：功能，参数，返回值

![image-20210819154121306](你好 桃子.assets/image-20210819154121306.png)

![image-20210819153953850](你好 桃子.assets/image-20210819153953850.png)

![image-20210819154636231](你好 桃子.assets/image-20210819154636231.png)

![image-20210819154657344](你好 桃子.assets/image-20210819154657344.png)

![image-20210819154752969](你好 桃子.assets/image-20210819154752969.png)

![image-20210819154902402](你好 桃子.assets/image-20210819154902402.png)

![image-20210819155030969](你好 桃子.assets/image-20210819155030969.png)

负数是从后面开始-1，不写结束位置就可以一直到那个

![image-20210819155434199](你好 桃子.assets/image-20210819155434199.png)

与上面功能类似，后面指的是长度

![image-20210819155742440](你好 桃子.assets/image-20210819155742440.png)

分割数组

![image-20210819160002471](你好 桃子.assets/image-20210819160002471.png)

![image-20210819155949778](你好 桃子.assets/image-20210819155949778.png)

![image-20210819160229688](你好 桃子.assets/image-20210819160229688.png)

![image-20210819160605274](你好 桃子.assets/image-20210819160605274.png)

![image-20210819161459494](你好 桃子.assets/image-20210819161459494.png)

![image-20210819161641497](你好 桃子.assets/image-20210819161641497.png)

## es6

![image-20210819161835944](你好 桃子.assets/image-20210819161835944.png)

![image-20210819161918687](你好 桃子.assets/image-20210819161918687.png)

返回 false

![image-20210819162005058](你好 桃子.assets/image-20210819162005058.png)

![image-20210819162048034](你好 桃子.assets/image-20210819162048034.png)

重复次数

## 数组方法

### 末尾增加删除 pushpop

![image-20210819162638218](你好 桃子.assets/image-20210819162638218.png)

![image-20210819162716582](你好 桃子.assets/image-20210819162716582.png)

### 从头部增加 unshift

![image-20210819163252695](你好 桃子.assets/image-20210819163252695.png)

### 从头部删除 shift

![image-20210819163320116](你好 桃子.assets/image-20210819163320116.png)

### 增删查改一体化 splice

![image-20210819163748793](你好 桃子.assets/image-20210819163748793.png)

![image-20210819163846690](你好 桃子.assets/image-20210819163846690.png)

![image-20210819164012252](你好 桃子.assets/image-20210819164012252.png)

### join

![image-20210819164447259](你好 桃子.assets/image-20210819164447259.png)

### split

将数组从某个元素切开形成新的数组

### 反转数组 reverse

![image-20210819164504381](你好 桃子.assets/image-20210819164504381.png)

# DAY 28

## 数组的方法

方法要记住 3 要素

### sort

![image-20210820145605873](你好 桃子.assets/image-20210820145605873.png)

b-a 降序，a-b 升序，需要在里边放一个回调函数

### slice

![image-20210820150312863](你好 桃子.assets/image-20210820150312863.png)

### value of

![image-20210820150422710](你好 桃子.assets/image-20210820150422710.png)

### tostring

![image-20210820150529918](你好 桃子.assets/image-20210820150529918.png)

![image-20210820150517236](你好 桃子.assets/image-20210820150517236.png)

![image-20210820150642007](你好 桃子.assets/image-20210820150642007.png)

![image-20210820150713009](你好 桃子.assets/image-20210820150713009.png)

函数对象在调用 valueof 的时候也是返回自身，tostring 返回的是自身加引号形成的字符串

![image-20210820152637309](你好 桃子.assets/image-20210820152637309.png)

只有包装对象是有基本值的，包装对象调用的 valueof 和 tostring 都是自身原型当中的方法

### 对象的数据转换

![image-20210820153105419](你好 桃子.assets/image-20210820153105419.png)

![image-20210820153139431](你好 桃子.assets/image-20210820153139431.png)

### 不同数据类型的计算

![image-20210820153824737](你好 桃子.assets/image-20210820153824737.png)

![image-20210820153856365](你好 桃子.assets/image-20210820153856365.png)

上下对比理解

![image-20210823105112779](你好 桃子.assets/image-20210823105112779.png)

### indexof

![image-20210820154532397](你好 桃子.assets/image-20210820154532397.png)

### 数组去重

![image-20210820154855550](你好 桃子.assets/image-20210820154855550.png)

![image-20210820155514810](你好 桃子.assets/image-20210820155514810.png)

### forEach 遍历数组

![image-20210820160217405](你好 桃子.assets/image-20210820160217405.png)

### map

![image-20210820160404635](你好 桃子.assets/image-20210820160404635.png)

# DAY 29

## 数组方法

### filter

遍历过滤产生一个新数组返回条件为 true 值

![image-20210821135846554](你好 桃子.assets/image-20210821135846554.png)

## 数组 es6 方法

### 伪数组和真数组的区别

有无可以使用数组的方法

### from

![image-20210821141554677](你好 桃子.assets/image-20210821141554677.png)

### of

![image-20210821141801263](你好 桃子.assets/image-20210821141801263.png)

如果只有一个数，of 是数组，new Array 是数组的长度

### find

![image-20210821142022829](你好 桃子.assets/image-20210821142022829.png)

会将数组中第一个大于 10 的值返回

### findIndex

![image-20210821142229746](你好 桃子.assets/image-20210821142229746.png)

### 打印字符串中出现字母出现最多的次数

![image-20210821150003622](你好 桃子.assets/image-20210821150003622.png)

![image-20210821150113821](你好 桃子.assets/image-20210821150113821.png)

![image-20210821153124832](你好 桃子.assets/image-20210821153124832.png)

# DAY 30

## ES 串讲

### ES5

1.变量，基本数据类型

2.运算符和表达式，数据类型转换

3.语句结构，if，for 案例

**4**.数组，定义，length，下标，操作，遍历，案例

**5**.函数，定义，函数的使用封装函数，函数的执行过程，作用域和全局变量，局部变量

**6**.对象，object 的实例对象，3 种定义方式，操作方式（点【】），遍历，数组函数也是对象

**7**.构造函数创建特定实例对象，函数也是对象，函数也是普通函数，函数当构造函数 this window 原型 原型链 instanceof 值类型和对象类型 内置 Json Date Math

8.方法：字符串方法 数组方法 对象数据类型怎么转换 valueOf toString

## DOM

DOM 是一个使程序和脚本有能力动态地访问和更新文档的内容、结构以及样式的平台和语言中立的接口。

DOM 描述了处理网页内容的方法和接口

window 是浏览器窗口对象，所有东西都被当作是 window 的子对象

文档对象 document 是 window 下的一个属性 代表整个 DOM 文档对象

根元素（root） html 标签

文档树(dom 树) 以 HTML 为根节点 形成的一棵倒立的树状结构，我们称作 DOM 树；这个树上所有的东西都叫节点，节点有很多类

 元素节点 标签

 属性节点 属性

 文本节点 内容

 注释节点 注释

 这些节点如果我们通过 DOM 方法去获取或者其它的操作去使用的话，就叫 DOM 对象

## window.onload

一般情况我们都是等待页面加载完成之后才去操作 dom 元素

如果页面没有加载完成就去获取 dom 元素，有可能获取不到；

window.onload = function(){

}等待页面加载完成，系统会自动执行函数当中的代码

浏览器一开始 onload 加载，pass 解析，random 渲染

![image-20210822103639205](你好 桃子.assets/image-20210822103639205.png)

![image-20210822104102214](你好 桃子.assets/image-20210822104102214.png)

![image-20210822104224041](你好 桃子.assets/image-20210822104224041.png)

### 1. document.getElementById

这个是 document 下的一个方法，通过 id 获取到相关元素 封装为 dom 对象返回，如果没有 id 没办法获取，这个方法只能获取一个 dom 元素对象

### 2.点击事件

 事件三要素

事件源 （承受事件的对象）

事件类型 onclick

事件处理回调函数

 事件处理三大步

获取事件源 DOM 对象

添加对应事件监听

书写处理回调

事件写好之后可以重复触发执行；

简单案例： 点击按钮实现一个数字自增；

## 修改特殊属性的天生属性

check=check 不能直接用，要用布尔值，check=true

![image-20210822105835027](你好 桃子.assets/image-20210822105835027.png)

![image-20210822110358437](你好 桃子.assets/image-20210822110358437.png)

# DAY 31

![image-20210823122502682](你好 桃子.assets/image-20210823122502682.png)

调用函数里边传的是{}证明穿的是地址，或者对象都传的是地址

出现【】代表出现新的数组，出现{}代表新的对象，都会有一个新的地址

## js 操作元素的自定义属性

![image-20210823124523825](你好 桃子.assets/image-20210823124523825.png)

this 代表事件源，pNode，因此可以用 this 代表 pNode

![image-20210823124842183](你好 桃子.assets/image-20210823124842183.png)

aa 就是自定义属性，自定义属性无法使用。语法和【】语法，

![image-20210823125141228](你好 桃子.assets/image-20210823125141228.png)

![image-20210823125302919](你好 桃子.assets/image-20210823125302919.png)

class 都不用加 name 了

## 其他方法获取 dom 对象

### getElementByTagName

通过标签名获得，获得多个对象的伪数组，伪数组不能使用数组的方法

![image-20210823125933199](你好 桃子.assets/image-20210823125933199.png)

### getElementByClassName

通过类名获得，获得多个对象的伪数组，伪数组不能使用数组的方法

![image-20210823130311671](你好 桃子.assets/image-20210823130311671.png)

### querySelector

通过 css 选择器去获取元素形成 dom 对象

![image-20210823130523640](你好 桃子.assets/image-20210823130523640.png)

li：nth-child（3）代表拿第三个 li，同一级孩子里面的第三个

![image-20210823130633966](你好 桃子.assets/image-20210823130633966.png)

![image-20210823130857182](你好 桃子.assets/image-20210823130857182.png)

## js 操作单个元素的内容

### innerText，innerHTML

获取文本内容 innerText 只是获取文本，innerHTML 带空白块，会获取内部的其他标签如果内部有其他标签的话

![image-20210823131236621](你好 桃子.assets/image-20210823131236621.png)

![ ](你好 桃子.assets/image-20210823131916438.png)

## js 操作多个元素的内容

点击任何一个 p 元素所有的内容都变

![image-20210823140524695](你好 桃子.assets/image-20210823140524695.png)

## 排他法操作轮播小圆点

先让所有的变成一个状态，再让选中的转换成另一个状态；

![image-20210823141130757](你好 桃子.assets/image-20210823141130757.png)

伪数组里边没有方法，querySelectorAll 取的是一个伪数组

![image-20210823141406881](你好 桃子.assets/image-20210823141406881.png)

运用 onclick 方法必须按照这样

![image-20210823143114555](你好 桃子.assets/image-20210823143114555.png)

点击一个让一个改变成一个另一个变成其他的，需通过 this 来实现，

![image-20210823144014232](你好 桃子.assets/image-20210823144014232.png)

也可以把下标存储起来，后面通过 this。index 拿下标修改，这是第二种方式

css 初始化

![image-20210823180826584](你好 桃子.assets/image-20210823180826584.png)

实际代码

CSS 代码

![image-20210823181915280](你好 桃子.assets/image-20210823181915280.png)

HTML

![image-20210823181941670](你好 桃子.assets/image-20210823181941670.png)

js 代码

![image-20210823182241209](你好 桃子.assets/image-20210823182241209.png)

## js 操作元素的样式（行内样式）

### 点击按钮改变样式

![image-20210823190048705](你好 桃子.assets/image-20210823190048705.png)

在 js 中，样式的--，在 js 中是用 marginLeft。后面的要大写

## 鼠标移入高亮显示

![image-20210823220649777](你好 桃子.assets/image-20210823220649777.png)

用

## 表格隔行变色

HTML 部分

![image-20210823221038088](你好 桃子.assets/image-20210823221038088.png)

js 部分

![image-20210823221128980](你好 桃子.assets/image-20210823221128980.png)

## 开关控制盒子变色

![image-20210823221516760](你好 桃子.assets/image-20210823221516760.png)

![image-20210823221733002](你好 桃子.assets/image-20210823221733002.png)

定义一个 flag

![image-20210823221943601](你好 桃子.assets/image-20210823221943601.png)

可以用 flag = ！flag 替换上面两句

## 开关控制风车的停和转

![image-20210823222747102](你好 桃子.assets/image-20210823222747102.png)

设置风车用 radius，设置了浮动之后父元素有高度就不会错，写了浮动要看父元素死不死

![image-20210823223450278](你好 桃子.assets/image-20210823223450278.png)

动画状态设置关键帧 animation 是一个动画效果

![image-20210823223756998](你好 桃子.assets/image-20210823223756998.png)

开关

![image-20210823224010437](你好 桃子.assets/image-20210823224010437.png)

jk 设置转和停止

# DAY 32

es5 多练敲代码

## 开关控制盒子显示和隐藏

### 隐藏的三种方式

display：none 这是隐藏不占位置

visibility：hidden 隐藏占位置

opacity：透明度 0

宽，高设置为 0

transform：translate（-xxxxpx）；

scale 缩放

skew90deg 扭曲，图上的是错的

![image-20210824093257432](你好 桃子.assets/image-20210824093257432.png)

以上都可以让盒子隐藏

![image-20210824094057509](你好 桃子.assets/image-20210824094057509.png)

以上的 querySelector 是类选择器所以要加#，获得 btn 的两种方式

## 兼容型封装读写元素

兼容性封装读写内容

浏览器的兼容性：

Chrome fireFox IE safari opera

浏览器分为高级浏览器和低级浏览器

以 IE8 为分水岭，包含 IE8 在内以下的就是低级浏览器

IE8 以上和其它的都是高级浏览器

元素的内容 innerText 和 textContent 区别

innerText 和 textContent 都是用来操作元素的文本（不会包含标签）

textContent 可以获取到隐藏的元素的内容

innnerText 获取不到；

textContent 只有高级浏览器才能用

innnerText 所有浏览器都能用

![image-20210824100324933](你好 桃子.assets/image-20210824100324933.png)

![image-20210824100536551](你好 桃子.assets/image-20210824100536551.png)

设置内容

函数优化

![image-20210824101341962](你好 桃子.assets/image-20210824101341962.png)

![image-20210824101548088](你好 桃子.assets/image-20210824101548088.png)

## 键盘事件

4 个输入框：input：type=text 文本输入框 password 密码输入框

radio 就是单选输入框 checkbox 就是多选输入框，，type 还可以设置成 Email，date，file3 种类型

3 个按钮：button 普通按钮，reset 重置按钮，submit 提交按钮

![image-20210824114142865](你好 桃子.assets/image-20210824114142865.png)

在文本框按下键盘任意数字就触发事件，从 keycode 就可以知道你按了哪一个键

![image-20210824115423041](你好 桃子.assets/image-20210824115423041.png)

通过 keycode 寻找到每次所点击的键盘是哪个一个键,回调函数的第一个变量就是出发按钮发生的事件

## 焦点事件随机颜色

![image-20210824115941036](你好 桃子.assets/image-20210824115941036.png)

![image-20210824120530217](你好 桃子.assets/image-20210824120530217.png)

![image-20210824121008860](你好 桃子.assets/image-20210824121008860.png)

![image-20210824121147059](你好 桃子.assets/image-20210824121147059.png)

防止拼接字符串错误，以上是随机颜色

## 全选，全不选，反选

![image-20210824121509854](你好 桃子.assets/image-20210824121509854.png)

![image-20210824121658307](你好 桃子.assets/image-20210824121658307.png)

label 是辅助标签，绑定字和框，通过点字或者点框都可以实现选中，通过 id 值放在 for 中，两种绑定方式

![image-20210824122059613](你好 桃子.assets/image-20210824122059613.png)

全选

![image-20210824122306107](你好 桃子.assets/image-20210824122306107.png)

全不选和反选代码

## 轮播图布局

### css 初始化

![image-20210824124811290](你好 桃子.assets/image-20210824124811290.png)

清除浮动

伪类的四种状态：link，after，hover，active

![image-20210824132256916](你好 桃子.assets/image-20210824132256916.png)

主体结构，不能出现高度为 0 的东西

![image-20210824131225462](你好 桃子.assets/image-20210824131225462.png)

rgba 为设置透明度和颜色，左右标签设置，左右居中，left50 transform -50%

ul 设置成 div 的倍数，以图片张数为倍数，然后 li 设置成图片的大小

![image-20210824131727943](你好 桃子.assets/image-20210824131727943.png)

小圆点样式

![image-20210824131905025](你好 桃子.assets/image-20210824131905025.png)

## 轮播图鼠标移入移出渐变 onmouseenter leave

![image-20210824145907049](你好 桃子.assets/image-20210824145907049.png)

左右两个小箭头设置渐入渐出特效，设置透明度，渐变时间设置两秒

![image-20210824150303026](你好 桃子.assets/image-20210824150303026.png)

通过 js 设置渐入渐出效果，当鼠标指向 div，span 渐变，transition 改变的时候值是直接变得，但是效果是慢慢改变的，只能对有连续值的东西添加效果

## 二级菜单移入移出显示和隐藏

![image-20210824151459549](你好 桃子.assets/image-20210824151459549.png)

给盒子设置 box-sizing ： border-box 就是设置底部边框

![image-20210824152832951](你好 桃子.assets/image-20210824152832951.png)

js 设置一级菜单的 li 和二级菜单的 ul 相同，所以可以这样子设置

## 翻牌操作

![image-20210824154004482](你好 桃子.assets/image-20210824154004482.png)

![image-20210824154147159](你好 桃子.assets/image-20210824154147159.png)

3D 变换需要在父元素开启 3d 空间，如果子元素做了 3d 旋转，如果父元素没开启，可以加个 transition 加一个延迟效果

perspective 景深效果

![image-20210824154556507](你好 桃子.assets/image-20210824154556507.png)

主体结构以及 js 语句

## 幽灵按钮

![image-20210824161312010](你好 桃子.assets/image-20210824161312010.png)

js 部分

css 部分是通过将两边的宽度设置为 0，通过 js 改变宽度实现

# DAY 33

## 子节点和子节点元素节点三要素

childNodes 拿到的是某个元素的子节点：包括元素子节点和文本子节点，如果有注释还有注释节点；

 children 拿到的是某个元素的子元素节点

 子节点:childNodes (儿子节点):

 高级浏览器: 元素,文本(文本,空格,换行),注释

 低版本浏览器: 元素,文本(不包括空格和换行),注释

 子元素节点： children(儿子元素):

 高级浏览器:元素

 低版本浏览器:元素,注释

 案例：获取元素的子节点和子元素

所有节点通过 dom 拿到都是对象

## nodename

![image-20210825102106800](你好 桃子.assets/image-20210825102106800.png)

节点三要素

![image-20210825102844346](你好 桃子.assets/image-20210825102844346.png)

## 父节点

![image-20210825103750832](你好 桃子.assets/image-20210825103750832.png)

## 获取节点的其他方式

![image-20210825124325158](你好 桃子.assets/image-20210825124325158.png)

![image-20210825124425803](你好 桃子.assets/image-20210825124425803.png)

第一个获取的是 text，第二个是 li

获取第一个子节点（包括注释，空格）和子元素节点

![](你好 桃子.assets/image-20210825124819951.png)

获得上一个兄弟元素节点，加了 element 只有高级浏览器才认识 ie8 以上，父子和兄弟两种获取方式

## 兼容型

![](你好 桃子.assets/image-20210825130121047.png)

![image-20210825130255286](你好 桃子.assets/image-20210825130255286.png)

### while

当不知道循环多少次的时候用它

ch

## 创建节点的三种方式

一般指的节点就是元素节点

![image-20210825143028102](你好 桃子.assets/image-20210825143028102.png)

=代表修改

![image-20210825143829300](你好 桃子.assets/image-20210825143829300.png)

第三种方式是我们最经常用的方式，appendChild，是追加的意思

## 动态创建添加列表使用第二种第三种方法

![image-20210825144837393](你好 桃子.assets/image-20210825144837393.png)

通过 js 动态添加所需内容

![image-20210825145055321](你好 桃子.assets/image-20210825145055321.png)

最终再返回页面

![image-20210825145536119](你好 桃子.assets/image-20210825145536119.png)

第三种方式创建，用的最多

## 节点常用的增删改查

节点的增删改

    * 以下方法都是父元素调用,操作子元素
    * ![image-20210825150854995](你好       桃子.assets/image-20210825150854995.png)
    
    * 插入节点: insertBefore(新节点,参照节点);，前面代表新增的元素后边代表插在谁的前面
    * ![image-20210825151152080](你好       桃子.assets/image-20210825151152080.png)
    
    * 替换节点: replaceChild(新节点,被替换的节点);类似于插入，前面是替换元素后面是位置
    * ![image-20210825151431800](你好       桃子.assets/image-20210825151431800.png)
    
    * 删除节点: removeChild(被删除的节点);
    * ![image-20210825150155629](你好       桃子.assets/image-20210825150155629.png)

 \* 追加节点：appendChild(被追加的节点)；

 节点.remove（pc 端 ie 不支持）

![image-20210825151712593](你好 桃子.assets/image-20210825151712593.png)

删除整个 ul，通过找到父元素再删除 body 里的元素，用 ulNode。parentNode。removeChild 或者用 documengt。body。removeChild 都可以找到 body

## 案例：使用列表演示节点

表单中获取内容（input），就是获取其内部的 value 值，非表单就通过 innertext、innerHTML 获取

在 input 输入内容回车后发生相应

![image-20210825153049926](你好 桃子.assets/image-20210825153049926.png)

![image-20210825153208787](你好 桃子.assets/image-20210825153208787.png)

## 键盘事件和查询结合

![image-20210825153346129](你好 桃子.assets/image-20210825153346129.png)

通过回车触发事件

![image-20210825153502620](你好 桃子.assets/image-20210825153502620.png)

回车完之后原来的搜索框变为空

## trim 字符串方法

![image-20210825174322721](你好 桃子.assets/image-20210825174322721.png)

去除左边的空格以及去除右边的空格

![image-20210825174509489](你好 桃子.assets/image-20210825174509489.png)

![image-20210825174642807](你好 桃子.assets/image-20210825174642807.png)

![image-20210825174922096](你好 桃子.assets/image-20210825174922096.png)

通过 trim 如果为真证明输入框不为空，合法不合法都要返回空的 value 值

![image-20210825175504789](你好 桃子.assets/image-20210825175504789.png)

设置移入移出高亮，这种方法比较麻烦，需要重复遍历浪费内存，每加一个都会让所有的 li 重新添加一遍

![image-20210825175837442](你好 桃子.assets/image-20210825175837442.png)

通过这种方法可以提高效率，是以上图的改良

# DAY 34

## 求数组交集

![image-20210826103433357](你好 桃子.assets/image-20210826103433357.png)

数组去重取反就行了

## dom0 事件的绑定和解绑

多用于 pc 端

![image-20210826105038303](你好 桃子.assets/image-20210826105038303.png)

本质上就是把 onclick 的函数和属性变为 null 就行了

## dom2 事件的绑定与解绑

多用于移动端

![image-20210826111935785](你好 桃子.assets/image-20210826111935785.png)

dom2 事件的添加方式，如果添加多次不会覆盖会依次执行

![image-20210826112632971](你好 桃子.assets/image-20210826112632971.png)

解绑必须是同一个函数，因此需要在外边定义一个有名函数

![image-20210826113509161](你好 桃子.assets/image-20210826113509161.png)

高级浏览器和低级浏览器解绑 dom2，低级加个 on

![image-20210826114210244](你好 桃子.assets/image-20210826114210244.png)

兼容性封装

![image-20210826134350648](你好 桃子.assets/image-20210826134350648.png)

![image-20210826114350889](你好 桃子.assets/image-20210826114350889.png)

后期添加函数添加 addEvent 就可以了

## 事件流及阻止事件冒泡

![image-20210826123739097](你好 桃子.assets/image-20210826123739097.png)

点击一个老末其他也会打印都在同一个地方里边，事件传播是客观存在的，会一直往上传递一直到 document，以上是 dom1，冒泡

![image-20210826124719440](你好 桃子.assets/image-20210826124719440.png)

dom2，第三个参数可以设置捕获或者冒泡，默认为冒泡，这是捕获

标准事件流分为 3 个阶段：1，捕获，2，目标，3，冒泡

![image-20210826134148060](你好 桃子.assets/image-20210826134148060.png)

捕获基本不用，高级浏览器可以根据第三个参数设置

### 阻止事件流

事件流（事件传播）每个事件都是必不可免的，也就是说每个事件都会进行冒泡；冒泡的情况下，如果是父子元素都添加了相同的事件监听，那么事件处理会从内到外依次执行；但是有些时候，我们确实是这样的结构，但是又不想让父元素事件进行处理；此时：我们就要用到阻止事件冒泡；

 阻止冒泡的时候，想在哪个元素阻止，需要在哪个元素的事件回调处理函数当中加上这一行；

 event.stopPropagation();//专门用来阻止事件冒泡用的；

![image-20210826134840425](你好 桃子.assets/image-20210826134840425.png)

## 事件委派

![image-20210826140223633](你好 桃子.assets/image-20210826140223633.png)

防止拿到了 ul，我们要拿 li

![image-20210826140438929](你好 桃子.assets/image-20210826140438929.png)

通过事件委派来提高添加效率，假如要加入很多相同的元素可以通过父元素的，，e 是回调函数，我们用来取 nodeName 的

## 事件委派的第二种应用场景

![image-20210826160423904](你好 桃子.assets/image-20210826160423904.png)

![image-20210826160737155](你好 桃子.assets/image-20210826160737155.png)

原始做法，有了事件委派之后更加方便

![image-20210826160951252](你好 桃子.assets/image-20210826160951252.png)

不管新的老的都会添加。

## 两对移入移出事件的区别

![image-20210826162524081](你好 桃子.assets/image-20210826162524081.png)

![image-20210826162619547](你好 桃子.assets/image-20210826162619547.png)

上面那个移入内部元素会有事件切换，下面那对不会，多用 over 和 out

![image-20210826162733420](你好 桃子.assets/image-20210826162733420.png)

## bom 相关 5 个对象

·1.打印视口的宽高![image-20210826165007027](你好 桃子.assets/image-20210826165007027.png)

2.获取滚动

![image-20210826165219299](你好 桃子.assets/image-20210826165219299.png)

### window 对象（bom 的顶级对象）

var a; window.a

function fn(){} window.fn()

document window.document

window.onload

window.onresize

window.onscroll

### location

![image-20210826165555136](你好 桃子.assets/image-20210826165555136.png)

window.location 可以让用户获取当前页面地址以及重定向到一个新的页面。window.location.href 可以读也可以写，写的时候相当于转向另外一个页面

### history

![image-20210826165922137](你好 桃子.assets/image-20210826165922137.png)

window.history 对象包含浏览器的历史记录，window 可以省略。这些历史记录以栈的形式保存。页面前进则入栈，页面返回则出栈。

### navigator

### ![image-20210826170531395](你好 桃子.assets/image-20210826170531395.png)

是一个只读对象，它用来描述浏览器本身的信息，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。

### screen

提供了用户显示屏幕的相关属性，比如显示屏幕的宽度、高度，可用宽度、高度。



## event 对象

### event 概念，作用

 系统给我们封装的，任何事件都会有这个 event 对象，这个对象当中封装了和这个事件相关的一切信息；

### event 兼容性处理

 如果是高级浏览器去调用函数的回调函数，它会把事件对象封装好传给回调函数的第一个形参;

 如果是低版本浏览器去调用，它会把事件对象封装好作为 window 的一个属性 window.event

所以我们在去拿事件对象的时候，要兼容性去拿

一般写 event 要加下面那句话

![image-20210826171518518](你好 桃子.assets/image-20210826171518518.png)

event = event || window.event;

## target

target 兼容性写法

![image-20210826172112614](你好 桃子.assets/image-20210826172112614.png)

### 目标元素节点兼容处理

event.target || event.srcElement

### 阻止事件冒泡兼容处理

高端。event.stopPropagation()

低端。window.event.cancleBubble = true

### 4 种鼠标位置

clientX & clientY

拿的是鼠标相对视口的 水平距离和垂直距离 相对的是视口的左上角（以视口左上角为原点）

 pageX pageY

拿的是鼠标相对页面的 水平距离和垂直距离 相对的是页面的左上角（以页面左上角为原点）

 offsetX offsetY

拿的是鼠标相对自身元素的 水平距离和垂直距离 相对的是自身元素左上角（以自身元素左上角为原点）

## 案例学生管理系统

网页拿到的东西都是字符串，需要计算的话需要转换类型

![image-20210826194026898](你好 桃子.assets/image-20210826194026898.png)

![image-20210826194149408](你好 桃子.assets/image-20210826194149408.png)

![image-20210826194318811](你好 桃子.assets/image-20210826194318811.png)

注意 tr 的 父元素是 tbody 不是 table

![image-20210826195200778](你好 桃子.assets/image-20210826195200778.png)

添加完，后要清空，后用事件委派删除

# DAY 35

## event 中三种鼠标位置

鼠标的位置存在于事件对象当中

![image-20210827141554462](你好 桃子.assets/image-20210827141554462.png)

clientX，clientyY 是相对视口拿的位置，只读

pageX 和 pageY 相对于页面，只读

offsetX 和 offsetY 是相对于自身

**\*\*scrollTop 可读可写\*\***

 **\*\*拿的是盒子内容向上滚动的距离\*\***

 **\*\*scrollLeft 可读可写\*\***

**\*\*拿的是盒子内容向左滚动的距离\*\***

![image-20210827142005877](你好 桃子.assets/image-20210827142005877-16300452066561.png)

通过此方法来经行调试

![image-20210827142111977](你好 桃子.assets/image-20210827142111977.png)

直接用。clientX 和 clientY 进行调用

## 鼠标跟随

![image-20210827143037904](你好 桃子.assets/image-20210827143037904.png)

图片跟着鼠标移动，要数值那加‘px’

## 定时器

### 延迟定时器

![image-20210827143501523](你好 桃子.assets/image-20210827143501523.png)

![image-20210827143736494](你好 桃子.assets/image-20210827143736494.png)

清除定时器用的是编号

![image-20210827143939643](你好 桃子.assets/image-20210827143939643.png)

可以设置一个按钮来清除定时器

### 循环定时器

类似循环但是不是循环

![image-20210827144420002](你好 桃子.assets/image-20210827144420002.png)

### 清除定时器

![image-20210827230324361](你好 桃子.assets/image-20210827230324361.png)

用计数器计算，当打印 10 次就清除

![image-20210827230800314](你好 桃子.assets/image-20210827230800314.png)

![image-20210827230723493](你好 桃子.assets/image-20210827230723493.png)

# DAY 36

## 万年历和阅读协议

![image-20210828161955099](你好 桃子.assets/image-20210828161955099.png)

将时间 date 放到时间循环中一秒刷新一次就可以实现刷新

## 阅读协议

![image-20210828163710530](你好 桃子.assets/image-20210828163710530.png)

## 同步和异步操作

同步操作指同一时刻只干一件事，异步指的是同一时刻做两件事

所有的定时器事件回调都是异步操作（事件 ajax 生命周期回调都是异步代码）；

 对于我们的代码，以后我们可以认为代码分为同步代码和异步代码；

异步代码是要等同步代码执行完成之后才会执行的；（js 是单线程的）；

## 元素大小位置

外边距重叠：内部盒子设置边框，margin，margin 就会作用到外部的盒子里

![image-20210828184509060](你好 桃子.assets/image-20210828184509060.png)

![image-20210828185438960](你好 桃子.assets/image-20210828185438960.png)

![image-20210828185721921](你好 桃子.assets/image-20210828185721921.png)

## 导航跟随案例

![image-20210828190940155](你好 桃子.assets/image-20210828190940155.png)

采用固定定位 position=fixed

![image-20210828191421829](你好 桃子.assets/image-20210828191421829.png)

## 盒子来回移动

![image-20210828192426874](你好 桃子.assets/image-20210828192426874.png)

![image-20210828192908724](你好 桃子.assets/image-20210828192908724.png)

## 初始包含块

![image-20210828193740204](你好 桃子.assets/image-20210828193740204.png)

## 系统滚动条设置

overflow：scroll 就会有滚动条，在 HTML 设置会作用到 document 上，禁止滚动条就在 HTML 和 body 设置 overflow：hidden

### **\*\*3\*\*\*\*\***\*.\***\*\***\*禁止系统滚动条\*\*\*\*

html,body{

 height:100%;

overflow:hidden;



}

为什么要加 height:100%;

这个属性加上只是为了让设置更有说服力，只有内容超出才会被掩藏或者出现滚动条, 如果不设置，那么 body 和 html 高度将由内容自动撑开，也就是说 body 当中的内容永远不会溢出。overflow:hidden;

# DAY 37

## 拖拽基础

元素起始位置加鼠标移动位置就等于最终元素的位置

![image-20210829104041469](你好 桃子.assets/image-20210829104041469.png)

盒子样式 absolute，就是相对于初始包含块的

![image-20210829104406889](你好 桃子.assets/image-20210829104406889.png)

获取鼠标的起始位置以及元素的起始位置

![image-20210829105416778](你好 桃子.assets/image-20210829105416778.png)

移动的位置就等于

鼠标距离差加上元素起始位置

![image-20210829105601090](你好 桃子.assets/image-20210829105601090.png)

求出位置后设置给元素，还要把鼠标抬起的时候的位置固定

![image-20210829105824785](你好 桃子.assets/image-20210829105824785.png)

将 move 时间解绑才可以放下盒子

![image-20210829105957679](你好 桃子.assets/image-20210829105957679.png)

第一次拖拽和第二次拖拽没有关联最好去掉 onmouseup

## 拖拽基础问题解决

鼠标移动过快会影响效果，应该把事件添加给 document，处理 box，在 document 触发，但是作用在 box 上

### 1

![image-20210829111043975](你好 桃子.assets/image-20210829111043975.png)

![image-20210829110703163](你好 桃子.assets/image-20210829110703163.png)

### 2

![image-20210829111313629](你好 桃子.assets/image-20210829111313629.png)

![image-20210829111356351](你好 桃子.assets/image-20210829111356351.png)

![image-20210829111437368](你好 桃子.assets/image-20210829111437368.png)

### 3

![image-20210829112209193](你好 桃子.assets/image-20210829112209193.png)

![image-20210829112551459](你好 桃子.assets/image-20210829112551459.png)

全局捕获，直接调用，有且调用就可以解决那个鼠标禁止移动事件，低级浏览器才有全局捕获，所以要加上 box。setcapture&&

![image-20210829113323999](你好 桃子.assets/image-20210829113323999.png)

执行完就要释放全局捕获用 release，全局捕获有设置就要释放，否则问题多

### 4

临界值设置

![image-20210829114615932](你好 桃子.assets/image-20210829114615932.png)

## 拖拽基础加临界值的吸附效果

![image-20210829153303211](你好 桃子.assets/image-20210829153303211.png)

通过临界值设置小于，多少时突然变为 0 就可以了

## 拖拽基础加碰撞效果

要判断 8 个值来确定是否发生碰撞

![image-20210829154417296](你好 桃子.assets/image-20210829154417296.png)

![image-20210829154922127](你好 桃子.assets/image-20210829154922127.png)

符合 if 的就碰不到，剩下的就碰得到了，用 else

![image-20210829155017665](你好 桃子.assets/image-20210829155017665.png)

## 自定义滚动条先动起来

![image-20210829161402228](你好 桃子.assets/image-20210829161402228.png)

![image-20210829162353571](你好 桃子.assets/image-20210829162353571.png)

让内容滚动起来，要让 content 设置定位，滑块滚动的距离和内容滚动的方向相反

## 滚轮实践基础

 ie/chrome : mousewheel(dom2 的标准模式)

 event.wheelDelta

 上：120

 下：-120

 firefox : DOMMouseScroll(dom2 的标准模式)

 event.detail

 上：-3

 下：3

day16 滚轮，用标志位判断往上往下

## 滚轮条添加滚动事件

![image-20210829165506262](你好 桃子.assets/image-20210829165506262.png)

# DAY 38

## 报错找问题：

1.一般报错问题寻找：

1，如果没有报错就可能是 css 出问题，不然就是 css 或者 js 代码单词错了

2，如果报错：分 4 大类

r 变量没有定义，解决方法就是一行行代码执行找错， type 类型错误，不是对象当成对象用，rangeerror，超出范围的时候，syn 语法错误，分号中英文写错了

### 数组去重冒泡排序

数组的东西回过头复习一下

## 今日重点轮播图

### 轮播图逻辑

pc 端无缝切换需要在最前面加一张最后的图，需要在最后加一张最前的图，小圆点变色需要通过图片的下标逻辑来确定图片是跟那个点关联

## 定时器叠加现象

![image-20210830153412559](你好 桃子.assets/image-20210830153412559.png)

定义一个：isMove = flag

![image-20210830153602323](你好 桃子.assets/image-20210830153602323.png)

在清除完定时器后就直接 isMove = false

## 自动轮播

加一个循环定时器就行了，模拟点击右键

![image-20210830153950929](你好 桃子.assets/image-20210830153950929.png)

## 正则表达式

![image-20210830160853538](你好 桃子.assets/image-20210830160853538.png)

上述表示正则以及正则的方法，\d 代表一个数字字符，\D 代表非数字字符

![image-20210830201230678](你好 桃子.assets/image-20210830201230678.png)

自变量创建表达式，函数创建表达式

![image-20210830201936745](你好 桃子.assets/image-20210830201936745.png)

正则表达式注意事项

# DAY 39

## 正则表达式案例方法

### 使用方式

![image-20210901135719552](你好 桃子.assets/image-20210901135719552.png)

### 数字使用方式

![image-20210901135905741](你好 桃子.assets/image-20210901135905741.png)

关于数字的使用方式，用 d

![image-20210901140336600](你好 桃子.assets/image-20210901140336600.png)

{}是通用的

### 判断字符串是否存在 a，b 或 c

![image-20210901140656714](你好 桃子.assets/image-20210901140656714.png)

中括号的用法【】

### 判断字符串是否是一个 8 位的字符串（判断整体严格判断）

![image-20210901140859712](你好 桃子.assets/image-20210901140859712.png)

## 正则对象和字符串方法

![image-20210901141719044](你好 桃子.assets/image-20210901141719044.png)

![image-20210901142129638](你好 桃子.assets/image-20210901142129638.png)

后面加 i 代表忽略大小写

![image-20210901142538195](你好 桃子.assets/image-20210901142538195.png)

必须加 g，全局变量，不然会出现死循环

### 字符串方法

![image-20210901143109388](你好 桃子.assets/image-20210901143109388.png)

以后用字符串方法多

### replace

![image-20210901144055984](你好 桃子.assets/image-20210901144055984.png)

replace，第一个参数是正则，第二个是替换内容

## 案例

![image-20210901144548738](你好 桃子.assets/image-20210901144548738.png)

用 test 和 search 都可以找到

![image-20210901145132506](你好 桃子.assets/image-20210901145132506.png)

利用规则写一个完整的表达式，以后要用到正则表达式，直接百度，手机号码正则表达式，js

![image-20210901162130185](你好 桃子.assets/image-20210901162130185.png)

![image-20210901162754879](你好 桃子.assets/image-20210901162754879.png)

查找整个字符串

# DAY 40

## 总结面试题

![image-20210902162032718](你好 桃子.assets/image-20210902162032718.png)

基本数据类型赋值各自是各自

![image-20210903160203459](你好 桃子.assets/image-20210903160203459.png)

因为没有返回值，所以返回值是吃货和 undefined

![image-20210903160924768](你好 桃子.assets/image-20210903160924768.png)

# DAY 41

## 函数相关

![image-20210904134050678](你好 桃子.assets/image-20210904134050678.png)

大写的 Function 是函数的祖先，所有函数都是 Function 构造出来的

![image-20210904160840187](你好 桃子.assets/image-20210904160840187.png)

普通函数返回的是，this。name，和 this。age 里的数据，实例化对象返回的是 return 里的东西。

实例化对象和普通函数的两大不同点：this 指向不同，返回值不同。普通函数指向 windows，方法中的属性，指向调用的对象，

![image-20210904162316294](你好 桃子.assets/image-20210904162316294.png)

这道题的 this 指向的是 obj，所以修改的是赵丽颖和 32，这道题有点绕，加了 new 之后 this 就指向实例化对象。

## 立即调用函数

（function（）{}）（），立即调用函数的作用是防止内部函数被污染，以及函数初始化，隐藏函数实现

![image-20210905140352903](你好 桃子.assets/image-20210905140352903.png)

## 断点调试

![image-20210905151603432](你好 桃子.assets/image-20210905151603432.png)

不会进入到函数调用里边去，会直接执行完 fn 就结束，不执行 fn1，第二个

第三个会进入到函数调用里边，第四个会直接跳出函数里边的，到外边继续，正好与第三个相反，第五个是一个个走

![image-20210906141638989](你好 桃子.assets/image-20210906141638989.png)

让打的断点暂时失效

![image-20210906141836820](你好 桃子.assets/image-20210906141836820.png)

清除所有断点

![image-20210906142207485](你好 桃子.assets/image-20210906142207485.png)

## 执行上下文

call stack 执行栈

![image-20210906161807565](你好 桃子.assets/image-20210906161807565.png)

准备阶段分为 3 种，准备变量（创建执行上下文），确定 this 指向，形成作用域链（函数自身就创建一个 fn，全局就会创建一个全局变量）anonymous 匿名的意思

执行上下文分为，全局执行上下文以及局部执行上下文

创建函数执行上下文，执行上下文是给变量进行赋值以及查找相关打印的东西，。

函数的作用域链是由本身的作用域链加上全局的作用域链组成

具体看 js 高级

全局执行上下文（分为创建阶段和执行阶段）代码开始执行之前和之后
1、全局执行上下文压入执行上下文栈）
创建上下文阶段：
1、收集变量形成变量对象 函数 var 的变量会收集
预解析（其实在创建变量对象的时候已经做了预解析）
2、确定 this 指向（可以认为确定执行者）
3、创建自身执行上下文的作用域链
注意：同时确定函数在调用时候的上级作用域链。（根据 ECMA 词法去确定，看内部是否引用外部变量确定）

    	2、执行全局执行上下文
    		执行全局上下文阶段
    			为变量真正赋值
    			顺着作用域链查找要使用的变量或者函数执行

分为全局执行上下文和函数执行上下文

# DAY 42

## 闭包

闭包整体是一个对象

1.  如何产生闭包(条件)?

    - 函数嵌套
    - 内部函数引用外部函数的局部变量
    - 使用（调用）外部函数
      并且内部函数也要调用或者引用（针对谷歌）（因为部分浏览器会对内部函数做优化，内部函数不使用或者不引用，相当于没有）；

    2. 闭包到底是什么?
       - 理解一: 闭包是嵌套的内部函数(绝大部分人)
       - 理解二: 包含被引用变量(外部函数)的对象(极少数人)
       - 理解三： 所谓的闭包是一个引用关系，该引用关系存在于内部函数中，引用的是外部函数的变量的对象(深入理解)

    3、常见的闭包 1. 将函数作为另一个函数的返回值 2. 将函数作为实参传递给另一个函数调用 3. 使用闭包实现私有方法操作独立的私有属性
    4、闭包的作用 1. 延长外部函数变量对象的生命周期 2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数) 3. 注意： 浏览器为了性能后期将外部函数中不被内部函数使用的变量清除了

    5、闭包的生命周期

        1. 产生: 在嵌套内部函数定义完时就产生了(不是在调用)
        2. 死亡: 在嵌套的内部函数成为垃圾对象时

    6、自定义模块
    _ 具有特定功能的 js 文件
    _ 将所有的数据和功能都封装在一个函数内部(私有的)
    _ 只向外暴露一个包信 n 个方法的对象或函数
    _ 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能
    使用自调用和不使用自调用函数区别

    7、闭包的缺点和解决(内存泄漏和内存溢出)

        内存泄漏 ： 内存无法释放；
        内存溢出 ： 内存被撑爆；
        f = null;  解决方式；

## 闭包案例

![image-20210908102438786](你好 桃子.assets/image-20210908102438786.png)

没有形成闭包的情况下每次执行都去重新执行一遍，执行完就会清除空间

![image-20210908102712323](你好 桃子.assets/image-20210908102712323.png)

形成闭包的情况下，打印出来的是 1，2

## 闭包面试题 1

![image-20210908134452340](你好 桃子.assets/image-20210908134452340.png)

打印出来是 the window，window。name 会去找全局变量的 window

## 闭包面试题 2

![image-20210908134616280](你好 桃子.assets/image-20210908134616280.png)

外部函数的 this 指向 obj，内部函数的 this 指向 window

![image-20210908135131805](你好 桃子.assets/image-20210908135131805.png)

如果要用到外部的 this 需要用以一个变量存储外部的 this

## 闭包面试题 3

![image-20210909110125657](你好 桃子.assets/image-20210909110125657.png)

![image-20210909110816816](你好 桃子.assets/image-20210909110816816.png)

从头到尾走从左往右走

![image-20210909110956284](你好 桃子.assets/image-20210909110956284.png)

undefined 0 1 1

## 闭包面试题 4

![image-20210909111909337](你好 桃子.assets/image-20210909111909337.png)

![image-20210909112512382](你好 桃子.assets/image-20210909112512382.png)

函数预解析，预解析函数相当于变量 var foo = {}，var getname = {}，下面 foo。getname 相当于属性，变量和属性是不一样的

所以下面的 getname = 修改的是 function 里边的函数。prototype 就是给原型对象添加属性，加到实例化的对象里边的

![image-20210909113051771](你好 桃子.assets/image-20210909113051771.png)

window。getname 就要去找全局里的 getname

![image-20210909120324548](你好 桃子.assets/image-20210909120324548.png)

new foo（）就会先执行，有括号就执行了，在执行后面的

最后的两个 new new 就是将函数实例化

## 使用闭包自定义模块

![image-20210909130209907](你好 桃子.assets/image-20210909130209907.png)

给外部留接口修改内部数据，使用闭包原理的普通函数实现。

![image-20210909130653009](你好 桃子.assets/image-20210909130653009.png)

这种事 jquery 的做法，匿名函数自调用。

## 原型链

![image-20210909230855906](你好 桃子.assets/image-20210909230855906.png)

实例化对象调用的是原型对象里边的 eat，外边 person。eat 调用的是吃肉

![image-20210910094544476](你好 桃子.assets/image-20210910094544476.png)

原型链的最终形态

![image-20210910095601175](你好 桃子.assets/image-20210910095601175.png)

原型链终极形态，prototype，显示原型对象，--proto--隐式原型对象，_constructor_ 属性返回对创建此对象的数组函数的引用，consructor 构造器

![image-20210910100253772](你好 桃子.assets/image-20210910100253772.png)

都为 true

## 面向对象

![image-20210910101146603](你好 桃子.assets/image-20210910101146603.png)

![image-20210910102710592](你好 桃子.assets/image-20210910102710592.png)

封装继承多态，继承方法

![image-20210910104710528](你好 桃子.assets/image-20210910104710528.png)

用 call 来用借助父类构造函数实现属性的继承，继承属性

## 方法重写，方法重载（多态的两种表现）

![image-20210910105730696](你好 桃子.assets/image-20210910105730696.png)

子类方法重写，用和父类一样的名字重写方法

![image-20210910110227365](你好 桃子.assets/image-20210910110227365.png)

![image-20210910110411814](你好 桃子.assets/image-20210910110411814.png)

方法重载，可以传不同参数

## webworker 模拟多线程

![image-20210910223502173](你好 桃子.assets/image-20210910223502173.png)

分线程代码

![image-20210910223614549](你好 桃子.assets/image-20210910223614549.png)

主线程代码

# DAY 43VUE3

vue 路径，可以通过下图直接查看 vue 源代码

https://unpkg.com/vue@next

![image-20210911090912274](你好 桃子.assets/image-20210911090912274.png)

![image-20210911093102116](你好 桃子.assets/image-20210911093102116.png)

原生实现计数器的 js 代码

![image-20210911094640825](你好 桃子.assets/image-20210911094640825.png)

vue 写法

## template 两种写法

![image-20210911114601062](你好 桃子.assets/image-20210911114601062.png)

1.![image-20210911115336873](你好 桃子.assets/image-20210911115336873.png)

2.

![image-20210911115605642](你好 桃子.assets/image-20210911115605642.png)

# DAY 44

## VUE 基本语法

### methods 学习

n 我们在 methods 中要使用 data 返回对象中的数据：

p 那么这个 this 是必须有值的，并且应该可以通过 this 获取到 data 返回对象中的数据。

n **那么我们这个 this 能不能是\*\***window\***\*呢？**

p 不可以是 window，因为 window 中我们无法获取到 data 返回对象中的数据；

p 但是如果我们使用箭头函数，那么这个 this 就会是 window 了；

n **为什么是 window 呢？**

p 这里涉及到箭头函数使用 this 的查找规则，它会在自己的上层作用于中来查找 this；

p 最终刚好找到的是 script 作用于中的 this，所以就是 window；

n **this 到底是如何查找和绑定的呢？**

p 在我的公众号有另外一篇文章，专门详细的讲解了 this 的绑定规则；

p https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA；

p 认真学习之后你绝对对 this 的绑定一清二楚；

methods 不能使用箭头函数（）=》{}，会引起 this 指向出现问题，箭头函数的 this 是指向 window 的所以会引起错误

### mustache（双大括号）语法

开发辅助网站，snippet generator，用于生成代码片段

如果我们希望把数据显示到模板（template）中，使用最多的语法是 **“Mustache”语法 (双大括号)** 的文本插值。

p 并且我们前端提到过，data 返回的对象是有添加到 Vue 的响应式系统中；

p 当 data 中的数据发生改变时，对应的内容也会发生更新。

p 当然，Mustache 中不仅仅可以是 data 中的属性，也可以是一个 JavaScript 的表达式。

![image-20210914102030405](你好 桃子.assets/image-20210914102030405.png)

错误用法

![image-20210914102056383](你好 桃子.assets/image-20210914102056383.png)

双大括号里边必须是表达式而不是赋值语句

### v-once 指令

这样子指定元素或者组件就只能渲染一次

![image-20210914102924338](你好 桃子.assets/image-20210914102924338.png)

通过 v-once counter 的值不会发生改变，上面的会改变，这样子指定元素就只能

### v-text 指令

![image-20210914103432606](你好 桃子.assets/image-20210914103432606.png)

以上两种表达结果一致

### v-html

![image-20210914104959968](你好 桃子.assets/image-20210914104959968.png)

![image-20210914105021437](你好 桃子.assets/image-20210914105021437.png)

### v-pre

![image-20210914105612172](你好 桃子.assets/image-20210914105612172.png)

加了 v-pre 之后不会展现指令里的 message，而是展示 h2 里本身的内容

### v-cloak

![image-20210914111317929](你好 桃子.assets/image-20210914111317929.png)

使其原来的 css 属性不起作用，基本不用

### v-bind

v-bind 用于绑定一个或多个属性值，或者向另一个组件传递 props 值（这个学到组件时再介绍）；

n 在开发中，有哪些属性需要动态进行绑定呢？

p 还是有很多的，比如图片的链接 src、网站的链接 href、动态绑定一些类、样式等等

**绑定基本属性**

v-bind 有一个对应的**语法糖**，也就是简写方式。

在开发中，我们通常会使用语法糖的形式，因

为这样更加简洁。

![image-20210914122420267](你好 桃子.assets/image-20210914122420267.png)

![image-20210914122616178](你好 桃子.assets/image-20210914122616178.png)

要加冒号才能动态绑定

### v-bind 绑定 class

![image-20210914215951913](你好 桃子.assets/image-20210914215951913.png)

可以有多个键值对，也可以和默认的 class 结合

![image-20210914220313822](你好 桃子.assets/image-20210914220313822.png)

也可以将对象放到一个单独的属性中赋值给 class

![image-20210914220949514](你好 桃子.assets/image-20210914220949514.png)

也可以将返回的对象放到一个 methods 的一个方法中

![image-20210914221454404](你好 桃子.assets/image-20210914221454404.png)

v-bind 也可以用绑定数组，数组里边也可以写函数语法的，

# DAY 45

## v-bind 绑定 style

![image-20210921155642384](你好 桃子.assets/image-20210921155642384.png)

通过语法糖绑定 color，若直接加样式需要加单引号，否则会默认被认为是变量

![image-20210921155929904](你好 桃子.assets/image-20210921155929904.png)

fontSize 要用驼峰或者用-就要加上横杆才不会出错

![image-20210921160506588](你好 桃子.assets/image-20210921160506588.png)

如果要像那样子返回的话就要家上一个连接语法

![image-20210921161034974](你好 桃子.assets/image-20210921161034974.png)

v-bind 也可以绑定一个对象，用“”然后直接加个对象一般用驼峰来写，-比较麻烦要加‘’单引号

![image-20210921161406810](你好 桃子.assets/image-20210921161406810.png)

![image-20210921161447410](你好 桃子.assets/image-20210921161447410.png)

也可以用方法来写然后返回

![image-20210921161810668](你好 桃子.assets/image-20210921161810668.png)

![image-20210921162113528](你好 桃子.assets/image-20210921162113528.png)

用数组，是将两对象进行合并的，多个对象合并采用数组语法

## 动态修改属性名属性值

![image-20210921162912947](你好 桃子.assets/image-20210921162912947.png)

## v-bind 属性直接绑定一个对象

![image-20210921163416879](你好 桃子.assets/image-20210921163416879.png)

## v-on 绑定事件

![image-20210921231324705](你好 桃子.assets/image-20210921231324705.png)

v-on 语法糖 @ v-bind 语法糖：

![image-20210922001854711](你好 桃子.assets/image-20210922001854711.png)

绑定事件 v-on

![image-20210922001951936](你好 桃子.assets/image-20210922001951936.png)

## v-on 修饰符

![image-20210922003041831](你好 桃子.assets/image-20210922003041831.png)

。stop 阻止冒泡

![image-20210922003318564](你好 桃子.assets/image-20210922003318564.png)

这样就只要 enter 键会显示 keyup，用。enter

可以通过 event。target 获取我们输入的内容

# DAY 46

## 条件渲染

v-if v-else v-else-if

![image-20210922133144593](你好 桃子.assets/image-20210922133144593.png)

## v-model 双向绑定

![image-20210922133612388](你好 桃子.assets/image-20210922133612388.png)

通过输入框就可判断

## v-if 的注意事项

![image-20210922133826119](你好 桃子.assets/image-20210922133826119.png)

## template 元素

![image-20210922134010137](你好 桃子.assets/image-20210922134010137.png)

![image-20210922134259566](你好 桃子.assets/image-20210922134259566.png)

template 不会被渲染

## v-show

### v-show 和 v-if 的区别

![image-20210922135122449](你好 桃子.assets/image-20210922135122449.png)

![](你好 桃子.assets/image-20210922135100971.png)

## v-for

![image-20210922140041282](你好 桃子.assets/image-20210922140041282.png)

模板引擎

![image-20210922140227307](你好 桃子.assets/image-20210922140227307.png)

想要展示下标需要用上以上代码，可以在后面那里经行+1 就可以从 1 开始显示

![image-20210922140934256](你好 桃子.assets/image-20210922140934256.png)

遍历数据的各种方法

## v-for 和 template 的结合使用

![image-20210922141807908](你好 桃子.assets/image-20210922141807908.png)

## 数组的修改方法

![image-20210922142914466](你好 桃子.assets/image-20210922142914466.png)

可以用数组的方法修改，而且会自动渲染到 dom 里边

![image-20210922142958306](你好 桃子.assets/image-20210922142958306.png)

将添加的内容绑定到 movies 中然后渲染

![image-20210922143113185](你好 桃子.assets/image-20210922143113185.png)

![image-20210922143229520](你好 桃子.assets/image-20210922143229520.png)

生成新数组的案例

## v-for 中 key 的作用

![image-20210922154936296](你好 桃子.assets/image-20210922154936296.png)

## VNode

![image-20210922155018234](你好 桃子.assets/image-20210922155018234.png)

![image-20210922155626236](你好 桃子.assets/image-20210922155626236.png)

## 虚拟 dom

![image-20210922165118629](你好 桃子.assets/image-20210922165118629.png)

## 插入 f 元素

![image-20210922165819358](你好 桃子.assets/image-20210922165819358.png)

diff 算法，将原来的 vnodes 和新的进行对比

![image-20210922170701563](你好 桃子.assets/image-20210922170701563.png)

![image-20210922174000083](你好 桃子.assets/image-20210922174000083.png)

一般写 v-for 的时候会绑定 key，类似于上图：key=文本中的中西，可以极大得提高效率

# DAY 47

1.关于案例的 3 种实现方法

插值法，methods，computed

## computed 的使用

## 侦听器 watch

![image-20210924131617206](你好 桃子.assets/image-20210924131617206.png)

![image-20210924144516190](你好 桃子.assets/image-20210924144516190.png)

## 深度侦听、立即执行

![image-20210924145210448](你好 桃子.assets/image-20210924145210448.png)

开启深度侦听就可以侦听到，对象里面的属性改变了

，开启了立即执行不管是否发生时间都会执行一次、当使用了深度侦听，new 的值和 old 的值一致![image-20210925110007949](你好 桃子.assets/image-20210925110007949.png)

## watch 的其他方式

1.

![image-20210924151709916](你好 桃子.assets/image-20210924151709916.png)

![image-20210924151823557](你好 桃子.assets/image-20210924151823557-16324679059651.png)

此时也可以用箭头函数，箭头函数指向 created 喝上面的 this 指向一致

## watch 综合案例

已经实现

# DAY 48 vue3 表单和开发模式

## v-model 绑定表单

![image-20210925142908820](你好 桃子.assets/image-20210925142908820.png)

![image-20210925171302511](你好 桃子.assets/image-20210925171302511.png)

v-model 使用原理

![image-20210925171529226](你好 桃子.assets/image-20210925171529226.png)

### 双向绑定

![image-20210925143202248](你好 桃子.assets/image-20210925143202248.png)

通过 v-bind 就可以绑定 value 属性，使得 message 和 input 的值一致 。

![image-20210925144420444](你好 桃子.assets/image-20210925144420444.png)

添加一个事件将 input 框里的值，赋值给 message，从而达到双向绑定的的效果，通过 v-modle 就可以直接进行双向绑定省去上面几个步骤

### v-model 绑定 text area

![image-20210925172147520](你好 桃子.assets/image-20210925172147520.png)

### v-model 绑定 checkbox

![image-20210925172311565](你好 桃子.assets/image-20210925172311565.png)

label 绑定 input ，label for，对应 input 的 id 这样就可以选中文字进行选择

![image-20210925172857414](你好 桃子.assets/image-20210925172857414.png)

绑定多选框，若要显示什么值需要给，input 一个 value 不然识别不出要放啥到数组里边，返回的是一个数组

### v-model 绑定 radio

![image-20210925173254861](你好 桃子.assets/image-20210925173254861.png)

修改 type，type 就可以使得为原点还是小方框

![image-20210925173502508](你好 桃子.assets/image-20210925173502508.png)

并且是互斥得两个，当 v-model 绑定同一个就会互斥

### v-model 绑定 select

![image-20210925173939818](你好 桃子.assets/image-20210925173939818.png)

如果需要多选得话需要再 select 加一个 multiple 如下图

![image-20210925174124718](你好 桃子.assets/image-20210925174124718.png)

也可以通过 size 决定小框的高度![image-20210925175110313](你好 桃子.assets/image-20210925175110313.png)

### v-model 值绑定

![image-20210927201313494](你好 桃子.assets/image-20210927201313494.png)

从服务器中 v-for 获取数据然后绑定：value

![image-20210925182404311](你好 桃子.assets/image-20210925182404311.png)

### v-model 修饰符 lazy

![image-20210925182706125](你好 桃子.assets/image-20210925182706125.png)

v-model.lazy

### v-model 修饰符 number

默认是绑定 string 类型，不过进行比较的时候 javascript 会默认进行隐式转化，转化成相同类型的然后进行对比

v-model.number 就可以使内容都转化为数字类型

### v-model 修饰符 trim

![image-20210925191347928](你好 桃子.assets/image-20210925191347928.png)

可以通过 v-model。trim 来去掉输入栏里的空格以及空白字符

## 注册组件

### 注册全局组件

![image-20210925201007010](你好 桃子.assets/image-20210925201007010.png)

像创建一个 app 一样创建一个 component（组成部分），真实的开发就是一个个组件组成的 app.component(组件名称，组件对象)

### 组件名称

![image-20210926094021893](你好 桃子.assets/image-20210926094021893.png)

### 注册局部组件

![image-20210926094808513](你好 桃子.assets/image-20210926094808513.png)

注册全局组件若用不到会造成包过大，因此有了局部组件注册

![image-20210926095310771](你好 桃子.assets/image-20210926095310771.png)

![image-20210926095544074](你好 桃子.assets/image-20210926095544074-16326213542981.png)

在全局 app 中有个一属性 components：这里面就能注册局部的组件，这样子就可以在创建一个局部的组件，在 app 创建的局部组件只能在 app 中使用

## webpack

![image-20210926100625839](你好 桃子.assets/image-20210926100625839.png)

打包工具

![image-20210926100757716](你好 桃子.assets/image-20210926100757716.png)

有 node

## 对象的引用，浅拷贝深拷贝（补充）

![image-20210925132832034](你好 桃子.assets/image-20210925132832034.png)

浅拷贝：他是用 Object。assign（{}，info）；将 info 的值复制，并不是直接将地址指向新的，而是开辟一个新的空间存储，若对象里边还有对象，就会存储那个对象的地址

深拷贝：

![image-20210925142026084](你好 桃子.assets/image-20210925142026084.png)

利用 json 先将数组转为字符串，再转换回来形成一个新的对象，这个东西打印出来还是 kobe

## lodash

是一个第三方的库文件，可以用 clone 浅拷贝 cloneDeep 深拷贝，会生成一份新的文件

# DAY 49

## vue 组件化开发二

## webpack 局部

webpack 一般用的是局部的 -d，我刚刚安装的是-g 全局变量

![image-20210926123539477](你好 桃子.assets/image-20210926123539477.png)

用 npm init 进行局部打包，加上-y 代表后面所有的都是 yes

![image-20210926123724004](你好 桃子.assets/image-20210926123724004-16326310456102.png)

就会生成一个 package。json 的一个文件，之后继续安装就可以生成局部安装打包，加上-D 就是生成开发模式的包，还有一个是生产模式的包意思是用户手上用的，不用加-D 直接用

![image-20210926123933048](你好 桃子.assets/image-20210926123933048.png)

安装完后会生成俩 ing 个文件如下图

![image-20210926124253137](你好 桃子.assets/image-20210926124253137.png)

![image-20210926124339205](你好 桃子.assets/image-20210926124339205.png)

也可以经行打包，不然就要找到 node-modules 中的 bin 里面的 webpack，经行局部打包

也可以在 package。json 中经行打包

![image-20210926124608710](你好 桃子.assets/image-20210926124608710.png)

![image-20210926124651388](你好 桃子.assets/image-20210926124651388-16326316126163.png)

这样子之后就可以执行了

![image-20210926124828761](你好 桃子.assets/image-20210926124828761.png)

想安装哪个版本就这样子@版本号

### 创建局部 webpack

![image-20210926124959652](你好 桃子.assets/image-20210926124959652.png)

### webpack 默认入口

一般默认入口为 index.js，如果不是 index.js 的话就需要用![image-20210926125322839](你好 桃子.assets/image-20210926125322839.png)

给他指定一个入口防止出错

![image-20210926125400352](你好 桃子.assets/image-20210926125400352.png)

指定入口出口

![image-20210926125630079](你好 桃子.assets/image-20210926125630079.png)

一般创建一个 webpack 文件以这个命名，webpack 配置信息

![image-20210926130103458](你好 桃子.assets/image-20210926130103458.png)

通过 path 指定路径，然后可以用 resolve 的方法找到 build 的绝对路径，出口要绝对路径

### css 打包

![image-20210926162535573](你好 桃子.assets/image-20210926162535573.png)

通过在其他 js 文件里面打开 element 的依赖就可以 实现 element 的 css 打包了，他们是一个图结构，可以使用依赖来进行渲染 css

### css-loader

![image-20210926163614294](你好 桃子.assets/image-20210926163614294.png)

css 打包需要一个 loader 来帮助，因此需要下载一个 css-loader

在 ppt 中可以看如何配置 css-loader

### css-loader 的加载方式

![image-20210926164014485](你好 桃子.assets/image-20210926164014485.png)

1.在入口的前面加一个 css-loader！，一般不用

2.cli 方式一般不用

3.配置方式，

![image-20210926164143337](你好 桃子.assets/image-20210926164143337.png)

![image-20210926164240978](你好 桃子.assets/image-20210926164240978.png)

在 webpack。config。js 中进行配置

![image-20210926164314300](你好 桃子.assets/image-20210926164314300.png)

![image-20210926164427537](你好 桃子.assets/image-20210926164427537.png)

匹配以 css 结尾的就用 css-loader 加载，正则表达式/\.css$/

### style-loader

![image-20210926164952410](你好 桃子.assets/image-20210926164952410.png)

要想打包好的 css 有样式，还需要加载一个 style-loader，也跟 css-loader 一样下载

loader 是从下往上执行所以要将先执行的放下边否则会出现错误

![image-20210926165422699](你好 桃子.assets/image-20210926165422699.png)

上图如果需要传入一个额外参数就要变成一个对象{loader：style-loader，option：}

### webpack 处理 less 文件

![image-20210926170311136](你好 桃子.assets/image-20210926170311136.png)

打包工具的具体配置操作在 ppt 里有

### postcss

![image-20210926170534926](你好 桃子.assets/image-20210926170534926.png)

![image-20210926173041618](你好 桃子.assets/image-20210926173041618.png)

安装完之后要想样式出现浏览器前缀，就必须用到插件 autoprefixer

![image-20210926174013057](你好 桃子.assets/image-20210926174013057.png)

也可以用这个插件，这个插件功能更加强大

# DAY 50 1；02

## webpack 搭建 vue

### 打包图片

![image-20210927101232240](你好 桃子.assets/image-20210927101232240-16327087537791.png)

![image-20210927105519367](你好 桃子.assets/image-20210927105519367.png)

用 file-loader 进行图片打包 i，图片的正则要包括图片的各种格式

![image-20210927125148555](你好 桃子.assets/image-20210927125148555.png)

以及各种规则例如 output path 设置打包好后文件夹的名字

![image-20210927125329236](你好 桃子.assets/image-20210927125329236.png)

vue 脚手架也可以形成此文件夹

### 文件命名规则

![image-20210927125438998](你好 桃子.assets/image-20210927125438998.png)

### url-loader

![image-20210927130251794](你好 桃子.assets/image-20210927130251794.png)

![image-20210927130700769](你好 桃子.assets/image-20210927130700769.png)

设置将比较小的图片转化 base64 格式，大于 100kb 的不转化，就用 limit

# DAY 51

## webpack5

### asset model type

![image-20210928092226137](你好 桃子.assets/image-20210928092226137.png)

可以用 asset module type 来替换各种 loader，通过添加 4 中模块类型来解决

![image-20210928092509976](你好 桃子.assets/image-20210928092509976.png)

代码端通过 type 设置 asset，设置限制就如同上图

![image-20210928092713226](你好 桃子.assets/image-20210928092713226.png)

也可以设置打包后的文件名如上图设置

### 加载字体文件

![image-20210928093806787](你好 桃子.assets/image-20210928093806787.png)

字体文件打包

也可以通过 asset 打包

![image-20210928094146824](你好 桃子.assets/image-20210928094146824.png)

注意命名方式用 file-loader 就是 name，asset 就是用 filename

## 插件 plugin

### clearwebpackplugin

![image-20210928094902806](你好 桃子.assets/image-20210928094902806.png)

![image-20210928095636911](你好 桃子.assets/image-20210928095636911.png)

先在终端 npm install clear-webpack-plugin -D 然后进行上图配置，最后通过 plugins：{new CleanwebpackPlugin（）}，插件就绑定好了

### HtmlWebpackPlugin

![image-20210928100025381](你好 桃子.assets/image-20210928100025381.png)

![image-20210928100150243](你好 桃子.assets/image-20210928100150243-16327945122781.png)

不同的插件不同的定义方式，在 plugin 中还是这样子定义

![image-20210928103942123](你好 桃子.assets/image-20210928103942123.png)

defineplugin 是 webpack 内置的一个插件，我们可以通过它解决 base url 报错的问题

![image-20210928104225308](你好 桃子.assets/image-20210928104225308.png)

通过 BASE_URL：“‘./’”，就可以在当前目录寻找到 base——url 这个东西了

### copywebpackplugin

复制插件

![image-20210928105251613](你好 桃子.assets/image-20210928105251613.png)

![image-20210928105310020](你好 桃子.assets/image-20210928105310020.png)

导入跟上面几个插件类似

![image-20210928105809271](你好 桃子.assets/image-20210928105809271.png)

从哪复制到哪，并且忽略哪个

## webpack 开发模式

![image-20210928110310922](你好 桃子.assets/image-20210928110310922.png)

打包后的文件如何调试

![image-20210928110629750](你好 桃子.assets/image-20210928110629750.png)

如上图设置完之后就可以在浏览器进行更为方便的调试

## Babel 和 devServer

![image-20210928115943436](你好 桃子.assets/image-20210928115943436.png)

### babel

![image-20210928152852082](你好 桃子.assets/image-20210928152852082.png)

如果想要用 babel 转化相关函数，就要用相关插件，例如箭头函数，![image-20210928153332078](你好 桃子.assets/image-20210928153332078.png)

如上图

![image-20210928153644093](你好 桃子.assets/image-20210928153644093.png)

若需要两个以上的插件就类似上图那样写一个逗号然后进行

以上是 es6 转化为 es5

### Babel preset

![image-20210928153952611](你好 桃子.assets/image-20210928153952611.png)

Babel preset env，用 preset 就不用一个个设置插件

![image-20210928160823898](你好 桃子.assets/image-20210928160823898.png)

babel 执行原理

### Babel-loader

![image-20210928162219666](你好 桃子.assets/image-20210928162219666.png)

webpack 打包不会帮你转化代码，需要 Babel-loader 插件来进行转化，使用 babel 来转化代码

![image-20210928163324695](你好 桃子.assets/image-20210928163324695.png)

还得把 babel 的相关插件给导入进去

![image-20210928163802431](你好 桃子.assets/image-20210928163802431.png)

也可以用 preset 直接节省了插件的使用

### Babel 配置文件

![image-20210928164338661](你好 桃子.assets/image-20210928164338661.png)

我们也可以将 Babel 文件配置抽出来，然后进行单独的配置

## webpack 中对 vue 代码打包

![image-20210928172756446](你好 桃子.assets/image-20210928172756446.png)

不同版本解析

![image-20210928172901249](你好 桃子.assets/image-20210928172901249.png)

runtime 版本就是解析 template 的

![image-20210928174124681](你好 桃子.assets/image-20210928174124681.png)

不同类型的东西要安装相对于的插件才可以打包成功

![image-20210928174305735](你好 桃子.assets/image-20210928174305735.png)

也需要一个 compiler-sfc -D 才可以解析。vue 的东西

![image-20210928174547183](你好 桃子.assets/image-20210928174547183.png)

通过以上三步才可以完成.vue 的打包编译

## vite2 搭建 vue 环境

# DAY 52

## vite3 新增语法特性

## devserve 和 vue cli

通过搭建本地服务再配合热模块替换达到不用重新打包的效果

### 搭建本地服务

![image-20210928215302811](你好 桃子.assets/image-20210928215302811.png)

![image-20210928215509327](你好 桃子.assets/image-20210928215509327.png)

通过加--watch，通过 webpack-cli 就可以自动重新编译

![image-20210928215741479](你好 桃子.assets/image-20210928215741479.png)

也可以通过这样子来监听代码是否改变

### webpack-dev-serve

![image-20210928221248747](你好 桃子.assets/image-20210928221248747.png)

vscode 的一个插件

![image-20210928220520197](你好 桃子.assets/image-20210928220520197.png)

也需要通过 npm install 下载安装

然后在 webpack 设置打开 serve

### devserve-contentBase：’‘

如果不用 copywebpackplugin 插件，想要我们的文件被显示就用这个

![image-20210928223758880](你好 桃子.assets/image-20210928223758880.png)

修改了配置之后需要重新打包配置才会生效

### HMR 模块热替换

![image-20210929085154768](你好 桃子.assets/image-20210929085154768.png)

![image-20210929085254156](你好 桃子.assets/image-20210929085254156.png)

![image-20210929085342820](你好 桃子.assets/image-20210929085342820.png)

一般还要打开 target：‘web’，这样才不会有问题

![image-20210929085851713](你好 桃子.assets/image-20210929085851713.png)

热替换不能直接用上边那句话，需要通过加上一个 if 判断来进行否则还是会直接刷新界面

### hotOnly。host 配置

![image-20210929094933221](你好 桃子.assets/image-20210929094933221.png)

![image-20210929095130863](你好 桃子.assets/image-20210929095130863.png)

是放在 devserve 里边的

### port 。open。compress 其他配置

![image-20210929100608154](你好 桃子.assets/image-20210929100608154.png)

### proxy 跨域访问 axios![image-20210929100717268](你好 桃子.assets/image-20210929100717268.png)

![image-20210929101409559](你好 桃子.assets/image-20210929101409559.png)

![image-20210929101434747](你好 桃子.assets/image-20210929101434747.png)

![image-20210929101825820](你好 桃子.assets/image-20210929101825820.png)

为了去掉 api 需要重写，类似于上图，才可以正常的跨域去获取数据

### resolve 模块解析

![image-20210929110934836](你好 桃子.assets/image-20210929110934836.png)

通过这样导入文件就可以不用加后缀名，他就会通过这个去帮我们在自动寻找相对应后缀名

![image-20210929111028746](你好 桃子.assets/image-20210929111028746.png)

### alias 别名

![image-20210929232148144](你好 桃子.assets/image-20210929232148144.png)

@代表 src 里面的 js

### 开发环境和生产环境分离

![image-20210929232542238](你好 桃子.assets/image-20210929232542238.png)

![image-20210929232758011](你好 桃子.assets/image-20210929232758011.png)

通过 merge 插件可以将共同有的部分合并到那原来那两个中

![image-20210929233030864](你好 桃子.assets/image-20210929233030864.png)

根据上述步骤完成

![image-20210929233212184](你好 桃子.assets/image-20210929233212184.png)

合并完成之后要注意修改路径，public 的路径不用修改

# DAY 53

## vuecli 脚手架

![image-20210930084416045](你好 桃子.assets/image-20210930084416045.png)

![image-20210930084722297](你好 桃子.assets/image-20210930084722297.png)

### VueCLI 安装使用

![image-20210930090146108](你好 桃子.assets/image-20210930090146108.png)

通过选择需要的东西创建相关项目，选择是空格，下一步按回车

default 默认，违约

![image-20210930090529658](你好 桃子.assets/image-20210930090529658.png)

创建好的项目配置目录结构，assets 放的是资源的类似于图片资源，components 就是放各种组件的，vue 打包也是用 npmrun built

### cli 源码要去看一下

![image-20210930102502803](你好 桃子.assets/image-20210930102502803.png)

## vite

![image-20210930103405773](你好 桃子.assets/image-20210930103405773-16329692471791.png)

浏览器支持 es module 和弊端，因此有了 vite

1.先安装 vite

2.npx vite 创建本地服务，服务 3000 端口

3.打包完它相对于 webpack 有 3 大有点，（1）.可以不加后缀名导入文件的时候（2）.导入路径可以不适用绝对路径了，直接用 lodash-es（3）.js 文件请求没有 webpack 那么多

![image-20210930213735057](你好 桃子.assets/image-20210930213735057.png)

vite 也可以直接打包我们的 css，只要给它引入，vite 就类似与一个本地服务器

4.详细学习

less 文件的话需要安装一个 npm install less -D

想要显示浏览器前缀需要安装 postcss，它需要依赖插件，所以安装下面工具

![image-20210930214925318](你好 桃子.assets/image-20210930214925318.png)

![image-20210930215613949](你好 桃子.assets/image-20210930215613949.png)

安装完之后进行 postcss 配置就可以显示浏览器前缀了

vite 默认支持 ts 的支持，它都是请求相对应的文件，然后通过 vite 生成新的文件，浏览器才认识，变成 es6 的 js 代码

vite 对 vue 的支持

![image-20210930225227925](你好 桃子.assets/image-20210930225227925.png)

![image-20210930225726474](你好 桃子.assets/image-20210930225726474.png)

![image-20210930225745468](你好 桃子.assets/image-20210930225745468.png)

上述插件需要依赖以上 sfc 插件

### esbuild 解析

![image-20211001164609222](你好 桃子.assets/image-20211001164609222.png)

### vite 脚手架

# DAY 54 48

## VUE 组件拆分与嵌套

使用 vueCLI 创建一个 vue 项目

![image-20211001230844712](你好 桃子.assets/image-20211001230844712.png)



使用脚手架创建一个新的项目

![image-20211001225303099](你好 桃子.assets/image-20211001225303099.png)

注册那是 es6 的组件

引用![image-20211001225532688](你好 桃子.assets/image-20211001225532688.png)

![image-20211001230505578](你好 桃子.assets/image-20211001230505578.png)

## 组件 css 作用域

scope 作用域的意思

，一般我们有用类选择器，

## 组件的通信

![image-20211002142349044](你好 桃子.assets/image-20211002142349044.png)

### props

![image-20211002143623728](你好 桃子.assets/image-20211002143623728.png)

![image-20211002143710249](你好 桃子.assets/image-20211002143710249.png)

数组的模式注册 props，也可以用对象的形式注册 props，

![image-20211002144616734](你好 桃子.assets/image-20211002144616734.png)

一般用传输对象的形式，required 表示必须传，default 表示默认值

![image-20211002145122583](你好 桃子.assets/image-20211002145122583.png)

防止多个人调用的时候修改了里面的值

![image-20211002150035275](你好 桃子.assets/image-20211002150035275.png)

![image-20211002150138409](你好 桃子.assets/image-20211002150138409.png)

通过此命令就可以绑定组件里面的 class，使用前还必须关闭 inheritAttrs 改成 false，不然就会绑定到根 div 上

### $emit

![image-20211002154408802](你好 桃子.assets/image-20211002154408802.png)

当按钮发生点击，子组件传递给父组件

![image-20211002154556034](你好 桃子.assets/image-20211002154556034.png)

父组件通过监听就可以写相关的代码了

![image-20211002174935826](你好 桃子.assets/image-20211002174935826.png)

## 过渡画面案例

明天敲

## vue 组件化开发

1.先创建各个组件，以及拆分
2.引入组件，在 script下 引入 通过 import header from “。/路径” 
3.引入完成之后需要在 export default{{components:header : header}}//为防止与 h5 里面的标签冲突，一般用 header-nav-bar 横杠引入，注册的时候用HeaderNavBar，使用的时候用上诉格式，在template（模板）中使用
## 父子组件之间的通信

## style 里面的scoped是表示作用域防止样式污染
### 父组件传递给子组件props
1.可以通过props可以在组件上自定义attribute（属性），父组件可以给这些attribute赋值，子组件通过attribute的名称可以获得相应的名称
2. props有两种常用用法，1字符串数组，2对象类型，对象类型可以定义传参得类型，props:{title : string }

用法：子组件在export default{
  data(){return{}},父组件看可以在data 
  数组写法以及对象写法
  props：['title','content']，也可以跟对象{required：ture表示必传，type表示数据类型里面也可以跟数组让多个数据类型通过}
  如果是object类型需要跟上一个函数default（）{return{返回一个对象，引用类型的时候}}    对象或者数组必须是一个工厂函数获取
}进行如上设置后，父组件在引入子组件后可以在template中引入子组件，可以加入自定义的属性并赋值（父传子），一般用props（）{return}，这样子动态获取
3.props大小写如果是驼峰的话一般用-当连接符连接比较推荐，传值的时候
### 父组件传递给子组件props （道具）
props在子组件，父在子组件上传递给子组件，子组件用props接受，子组件用$emit 传递给父组件

### 组件绑定属性
1.可以通过 ：title=“xxx”绑定某个属性
2.可以通过 v-bind = “{xxx}”直接绑定一个对象，就可以将对象的属性都绑定进去
 3.非attribute（属性），绑定到子组件上，通过v-bind = "$attrs.id"可以绑定父组件的的非自定义attribute到子组件上，例如id，class,可以在子组件上绑定inheritAttrs选择：false就可以防止继承,父组件定义好了以后，子组件上用$attrs.id就可以防止警告。
 4.非props（小道具）绑定我们可以通过$attrs来访问所有的非props的attribute
 5.如果有多个根节点（子组件的根）的话要手动指定绑定到哪个上，不然会有警告
 6.v-model.number = "num",绑定文本框输入值
 ### 子组件传递给父组件$emits（发出）
 子组件触发事件父组件监听并坐相应操作下需要运用
三个步骤
1. 子组件emits[“add”，“sub”] ，也可以用对象的写法，为了进行参数验证，emits：{add：null，sub：null，addN：如果只有一个参数一般传递的是payload=>{}   ,如果穿的是多个参数用的是（num，name，age）=>{}，然后可以设置判断验证规定传的参数 }vue3一般都是先注册，然后触发  ，子组件在methods里设置{increment（）{this。$emit("add"，可以传多个参数)}}，就是指当前传给父组件add事件，
2.在父组件里边添加监听事件用v-on ，也就是@add=“xxx”，可以绑定文本框获得文本框里边的值经行相对应的操作，，例如上6.，然后在data之中return num，设置默认值0，当用户输入相对应的值后绑定给父组件进行相对应的操作counter+n的操作  
3.然后添加对应的操作

 ### 过渡动画实现，衣服鞋子，衣服节目，鞋子界面

 ## vue脚手架开发项目
 安装脚手架
 vue create +名称
进行设置的时候选中是用回车
 component组件

## 非父子组件的通信
主要有两种方式
### 1. Provide（提供）/Inject（注入）
非父子组件之间共享数据
Provide和Inject的基本使用
在父组件里边可以加一个provide属性，里面可以添加一个对象：{name：“xixi”，age：18}，然后再子组件里面用inject接收：[]，可以用一个数组接受
一般数据再data中，比如在name中有数据，provide要拿data中的数据，如果要拿data中的数据则需要吧provide当作一个函数对象使用，并且return一个对象，这样子this才能使用，当数据更新的时候，需要给数据的赋值设置成响应式的这样才可以动态更新。注：provide默认写成函数比较好.
方法： 通过引入computed计算属性 import {computed} from 'vue'，然后调用返回一个getter函数即computed（（）=>this.names.length）,就可以设置成响应式的。

### computed小补充
computed返回的是一个ref对象，所以取值的时候需要加length.value
### 2.Mitt全局事件总线使用
可以实现兄弟之间的通信
1. 安装mitt包，第三方库
2.导入mitt并引入，他是返回一个函数可以const（）封装一个emitter（发射体）对象
'''
import mitt from 'mitt';
const emitter = mitt ();
export default emitter ;
'''
3.使用的时候使用emitter.emit(“嘻嘻”,{补充嘻嘻里面的内容})向外发出想要通信的数据，监听的用emitter.on("事件"，(info传入值)=>{})，也可以监听所有的（“*”，（type，info））

4.取消mitt事件监听（1）emitter。all。clear（）（2）定义一个函数 function onfoo （）{}，通过函数的引用监听以及取消监听
  emitter。off（‘foo’，onfoo）
  emitter。on（‘foo’，onfoo）

## 插槽slot
用法抽取共性，预留位置用来展现不同的东西，子组件中，然后父组件添加其他元素
封装组件的时候可以用slot插槽来预留一个位置，让父组件来决定其的使用。

### 插槽的基本使用
<slot></slot>《button/》如果是没内容可以用单标签
插在某些东西之间，然后再父组件引用的标签之间进行插入内容（包括之间插入组件）

### 插槽的默认内容
<slot>在这里边写默认内容</slot>
如果放入多个内容，插槽也可以全部替换

### 具名插槽使用
 只能分配3个东西某个部分分配给某一个
 1.可以给每一个slot定义一个name
 2.使用一个template v-slot：name，
 3.然后将内容放入相对应的template中间
 4.补充，如果某个slot不带name，它就是默认有个default
 5.动态插槽名：，<template>v-slot：[name]，可以使用返回的数据（data return）当做插槽的名字，子组件则需要：name用v-bind，并且使用父传子props将父组件定义的名字绑定到插槽上,父组件
### 语法糖 v-slot可以换成一个#

### Vue渲染作用域
父级模板里所有的内容都是在父级作用域中编译的
子级模板里所有的内容都是在子级作用域中编译的

### 作用域插槽
用于访问子组件里面的内容解决渲染作用域的缺点
当组件被用来渲染一个数组元素的时候，使用插槽，并且插槽中没有显示每一项的内容的时候就用作用域插槽

即子组件里边的一些属性值可以通过作用域插槽把属性里面的值传到父组件中
子组件：
一般是通过template里面v-for = ‘（item，index） in names’ 
：key=‘item’ ，一般绑定还要给它绑定一个key ，然后将值绑定到slot里面，slot ：item = “item” ：index = “index”
父组件：
通过一个template包裹里面的内容，并且要给v-slot赋值 = (里面的值可以自己定义)“slotProps”，然后父组件想用里面相对应的值就可用slotProps.item/slotProps.index

默认插槽，独占默认
如果是默认插槽不是具名插槽的时候，可以放到组件里面，然后删掉template，这个叫做独占默认插槽缩写，若不理解可以去看笔记ppt

# axios封装和使用

### 切换组件案例
 categary（类别）catogary（目录）
 1.：class = “{active：如果等于true就触发点击事件，可以在后面写上等式，currentTab === item}”，然后就可以修改点击后的样式，也可以用下标
 2.@click = “itemClick（最好把参数传进去这样子下面写点击事件的时候更加方便item）”

### 动态组件的使用
一般页面少的情况，可以通过v-if判断是否是当前页面currentTab，v-else-if，v-else，用这3个判断是否是当前页面


动态组件使用的是component组件，通过特殊的attribute is实现
'''<component> :is = "xxx" </component>
'''
is 后面跟的值是component函数注册的组件（全局注册），或者是局部注册

可以直接在组件里面给对应的子组件传入相关值，传入数值的时候在前面加一个：表示传入的是一个num类型，不加的话默认穿的是字符串类型

### keep-alive
保持状态，这是一个内置组件
<keep-alive></keep-alive>,将我们所需要保持缓存的时候使用这个组件，否者默认销毁，将需要保持的存入keep-alive里面
keep-alive常见的属性 ：

1.include 可以跟字符串，正则，数组，写正则和数组都需要加一个：，否则就被理解成字符串，包括的才保存缓存，
注：一般我们定义组件最好给它赋值一个name属性，就叫当前组件的名字，这样子用keep-alive的时候它首先检查组件自身的name选项

2.exclude任何名字匹配的组件都不会被缓存

3.max，最多可以缓存多少组实例，一旦达到那么缓存组件中最近没有被访问的实例就会被销毁

## 异步组件的使用 webpack分包
通过import函数导入模块，import（“路径”）返回的是一个promise，这样子打包的时候webpack就会将它另外打包，这样子就变成异步组件的打包。

## 异步组件defineAsyncComponent 
是vue给我们提供的一个函数，它可以传递两个类型的参数，
1.工厂函数，该工厂函数需要返回一个promise对象
引入defineAsyncComponent from vue ，然后
const AsyncCategory = defineAsyncComponent（()=>import("路径")）。。

另一种写法
对象写法：
const AsyncCategory = defineAsyncComponent({
  loader:()=>import("./路径")，
  loadingComponent：loading
  })，写成对象可以传入更多属性，loadingComponent组件，占位的时候，当上组件未加载完，就显示这个 ，errorComponent，还有delay：2000 ，可以查官网，onError：function（err（错误信息），retry（尝试重新加载）,fail()，attempts（记录尝试次数））
  2.接受一个对象类型，对异步函数进行配置
### 异步组件和Suspense（悬念）
Suspense是一个内置全局组件，有两个插槽
1.default：如果default可以显示就显示default的内容

2.fallback（应急的）：如果default不能显示的话，就会显示fallback插槽的内容


使用方法：
<suspense>
<template #default/fallback><这里加插槽></template>
</suspense>

###  $refs
引用元素和组件 vue开发中不建议直接dom操作，在元素上绑定ref的attribute属性，这样组件就有了$refs,这个对象包括注册的所有元素，也可以绑定到自定义组件上，绑定到自定义组件上的时候，返回的值是一个proxy对象，是一个代理，返回的是一个组件实例，也可以直接调用子组件的方法或者数据
使用方法：
'''
<h2 ref = "title></h2>
methods ： {
  btnClick(){
    console.log(this.$refs.title)
  }
}
'''
用以上方法就可以取得相对应的元素经行dom操作



### $parent和$root
用于子组件中获取父组件或者根组件
在vue3中已经移除了$children获取子组件

### $el在组件里边可以拿到组件里面的的根元素

## 生命周期
生命周期函数是一些钩子函数，在vue某个时间会被vue源码内部进行回调

created 
生命周期流程
![image-20211027195349691](你好       桃子.assets/image-20211027195349691.png)
beforeCreate，created，beforeMount，mounted挂载完成，beforeUmount卸载之前，unmounted，beforeUpdate，update

用v-if如果条件判断失败就不会显示整一个template

### 缓存组件的生命周期组件
activated
deactivated 表示活跃不活跃

## 组件的v-model
双向绑定
如果用HTML原生的元素的时候，子组件拿值得时候用event.target.value    this.$emit("",)传出
子组件里的元素用    ：value = “modelValue”
根节点引用子元素得时候，子组件赋值v-model = “绑定值”

可以使用计算属性直接绑定input和外边的值
通过以下直接双向绑定得时候，就可以用计算属性
'''
props{title：，
      modelValue
    }
computed：{
   value：{
     value里面的参数不能和上面传的值一样
     set(value){this.$emit("update:modelValue",value)}，
     //set当设置input得时候会调用
     get(){
       return this.modelValue;
     }//当回传值得时候会调用
   }
}
'''

### v-model绑定两个参数，
就是在v-model:title="title",然后传的值就是title，

## element-plus组件库得使用动画的实现和过渡
toggle、切换键
### 动画的基本使用 transition单标签
1.条件渲染：v-if和v-show展示动画
2.动态组件
3.组件根节点
单个元素或者组件实现过渡动画的时候，可以用transition（过渡）来实现动画效果
vue3内置 transition标签，然后给它定义一个名字，然后就可以在样式里面写对应的样式，name：why，，如果没有给她一个name，就是用v-表示默认前缀

style 1.动画效果      .why-enter-from,
                      .why-leave-to{opacity:0透明度}
                      .why-enter-to,
                      .why-leave-from{opacity:1}
      2.如何触发       .why-enter-active,
                      .why-leave-active{transition:opacity 2 ease;}
### vue实现过渡动画的原理，transition
1.自动嗅探是否添加或者删除某些东西，就会在合适的时机给我们添加或者删除css样式
2.如果transition组件提供了JavaScript钩子函数，这些钩子函数也会在合适的时机被调用
3.如果没有找到JavaScript钩子并且没有检测到过渡动画，dom插入，删除操作就会立即执行
transition就需要from和to


### 动画效果css的animation
animation：name
过渡动画用transition，如果直接动画效果的话用的是animation，配合上@keyframes name {
  0%{}
  50%{}
  100%{}
}

scale /缩放
reserve 反转
### 同时设置过渡和动画（transition和animation）

设置-enter-from，-leave-to，-enter-active，leave-active，可以设置大小变化和渐变的动画他们是可以共存的，

不过如果两个时间不一致，需要给transition加一个type属性，来决定按照谁的动画时间，否则会出现突然一闪的效果

####  ：duration = 
此transition属性表示整个动画的时间，可以传入一个对象然后分别指定enter或者leave的时间

#### 过度的模式mode属性
mode=“in-out”，先进入动画实现，再执行离开动画
“out-in”，与上面相反
切换可以是元素也可以是组件，甚至是动态组件
例如：component     ： is = “isShow ？'home':'about'"
然后就可以控制子组件的动画效果

#### ：appear属性
可以控制页面打开时动画一开始是否显示或者隐藏，有true和false两个值

直接加appear 就代表为true


### 多个标签的动画效果

### animate.css 第三方库
使用方法：
1.安装库 npm install animate.css
2.导入  在main.js 里面直接import "animate.css"
3.使用animation动画或者animate提供的类,直接在animation里面结合transition一起使用


直接用class
### 自定义过渡class
enter-from-class = "要加上animate__animated 加入animate类",,这个class一般去GitHub的animate。css复制。 
enter-to-class
enter-active-class
leave-to-class
leave-from-class
leave-to-class


### gsap库 基于JavaScript
某些情况下用JavaScript完成动画效果更好
使用方法：
1.安装 npm install gsap
2.导入    document（文件）
3.使用相关api 可以去相关官网查对应的api

gsap的方法洋 gsap.to（target，{}）
gsap.from(target,{状态})、、、进入状态的时候用的

使用需结合animation使用

### JavaScript钩子
可以在transition用@before-Enter，@enter，@after-enter，@before-leave，@leave，@afterLeave， = "赋值"
：css属性 = “false”，这个会让vue跳过css检测，这样可以提高性能
，然后可以在methods写入方法，beforeEnter(){加入方法}

然后再methods ： {
  enter（el（element），done ）{
    gsap.from(target,{
      scale ： 0， 、表示进入的时候从scale 0 到恢复原来的状态
      x ： xxx  //表示translatex（200px）
      duration ： xxx   动画时间默认0.5秒
      onComplete ： done  、、，done一般在这里用，否则它会自动执行回调没有动画效果
    }),,从原来的状态进入到xxX状态
  }
}

### input知识点补充， 数字递增效果
type = “number” step = “100” v-model = “”
可以点一下加100




computed ： {
  showCounter（）{
    return this.shownumber;.toFixed(0),意思是不保留小数点
  }
}     不用计算属性直接监听也是可以实现的

watch : {

  counter(newValue){
    gsap.to(this,{duration : 1, showNumber : newValue})///这样子就可以将newValue的值赋值到showNumber里面，然后就可以在1秒的时间里面将值变化
  }
}

### 列表动画的使用
transition-group组件
里面有一个tag属性 = “p”，里面可以是一个标签，定义一个属性，则transition-group里面的元素就会被包括到一个p属性


### 数组回顾
如果想要加入push，最后边加，splice//拼接（第一个参数添加的位置，第二个参数是删除的个数，第三个是传入的数值）

随机数 return Math.floor(Math.random()*this.number.length)

给了transition一个name，就可以用class，，一般要块级元素才有效果，要把span转化为inline-block。

## 列表过渡动画
在style里面写，vue 新增了一个v-move 的class来完成动画
transition ： transform 移动时间动画

移出效果的时候还会存在卡顿的情况是因为块级元素移动的过程中还占据着块，所以需要设置一个移出的效果可以给移出效果设置一个绝对定位


![image-20211028224903469](你好       桃子.assets/image-20211028224903469.png)


### 列表洗牌动画

需要引入ladash库，在 lodash.shuffle（this。numbers）
这样子就可以生成新的列表会将所有洗牌

### 列表的交错过渡案例
通过gsap 延迟delay，，
li中   v-for 最好绑定一个key，v-for = “（item，index） in showNames  ：key = “item”  ：data-index：“index” ”，，，获取元素下标
用一个计算属性

computed：{
   showNames（）

  {                                                //keywoed就是input输入的东西，这样子包含输入框的东西就会用于生成新的数组
      return this.names.filter(item => item.indexOf(this.keyword)!== -1)
      用于形成新的数组，过滤器
  } 
}

然后就可以添加动画效果了，给要变得东西加一个name然后就可以添加对应的动画，
用css都是一整个动画移动比较生硬，
所以一般用js实现 最好，此为禁止css的动画效果：css = “false”
用钩子实现，用gsap库
@enter
@leave 

methods ； {
  enter（el，done）{gsap.to(el,{opacity:1,height:1.5em,onComplete:done,delay:dataset.index*0.5xxx  延迟的属性})}，这样子可以获得设置依次消除
  beforeenter（el，done）{el.style.opacity = 0 ;el.style.height = o}//这样子动画效果更好给初始值设置样式
  leave（el,done）{gsap.to(el,{opacity:0,height:0,onComplete:done})}
}


## Compositing API

### Mixin /混入 mix in和extends

组件之间有一些相同的逻辑，这样子就需要对相同的代码逻辑进行抽取

一个Mixin对象可以包含任何组件选项

所以当组件使用Mixin对象的时候，所有的Mixin对象的选项将被混合进去该组件本身的选项中

本质上也是一个js对象

使用方法：
1.新建一个demoMixin的文件 
'''
export const demoMixin = {
  data(){
    return{
      message:
    }
  },
  methods : {

  },
  created(){

  }
}
'''

2. 导入使用
import { demoMixin } from ""
在组件里面直接用mixins：[demoMixin],然后就可以直接跟组件里面的一起结合使用


全局组件混入 应用app的方法mixin，app。mixin（{}），然后就可以全局混入mixin

注意事项：合并规则
如果当前名字重复的话，有以下几种情况
1.data里面如果发生名称重复会保留组件里面的data

2.生命周期钩子函数hook，生命周期钩子会被放到一个数组里面并且都执行

3.methods，watch，和components，directives，对象类型的最终都会被合并，如果重复就会保留组件里面的东西

### extends 继承
类似于mixin
导入后在默认属性里面直接使extends：xxxxx，和mixin差不多
继承继承的是对象里面的东西不能继承网页的标签啥的

### options API
methods，watch那些在vue 2 里边是options api，现在转化成了Composition api
直接写setup(){},就减少了很多括号

options API 的不足
1.对应的属性在对应的功能模块编写，

因此写一个功能对应的代码逻辑会被拆分到各个属性中，拆分的过于分散，难以阅读和理解


所以将同意逻辑的代码整合在一起可读性会更强

setup（）{
  useCounter（）；
}
这就诞生了composition api  有的人也叫VCA  vue composition api

### composition api

解决options api的痛点，就是setup函数 （）{}
### setup使用

1.函数的参数
 setup(props,context){
   setup里面不可以使用this，他没有绑定this，所以他有默认参数props，如果想要用props里面的数据，props返回的是一个proxy对象
 }
 Context里面包含三个属性：attrs(非prop的attribute)，slots(父组件传递过来的插槽)，emit（内部需要发送事件的时候会用到）

context。attrs。id，啥的也可，slot ，emit发送事件的时候就可以拿到

也可以直接用解构的方法：（props，{attrs，slot，emit}），参数是固定的位置的
就不用加context了  直接attrs。id emit，，，解构之后就不是响应式的，要做一些其他操作才可以



2.函数的返回值

setup的返回值来代替data选项，他的返回值可以在template模板中使用
setup（）{
返回的也是对象
let counter = 100 
const increment = ()=>{counter++；console.log(counter);}
return {
  message ： “hello word”，
  counter，
}}
返回的不是响应式的,,setup 在create之前调用  ，
 编程里边一般用_做占位

 ### reactive api   反应的
 为了解决上诉不能响应式的问题
 reactive传入的必须是一个对象或者数组类型的，对于传入类型是有限制的

 使用的时候就用state.counter

 使用方法：
 import {reactive} from “vue”；

 const state = reactive（{counter：100}）

 然后再return的时候就是return state 就可以将counter变成响应式的

data（）{return数据也是应用相同的原理，也是用reactive将其进行响应式的对象


### ref api   reference引用
为了解决上述传入类型有限的问题
就可以用ref api来解决这个问题，
如果是要 传入的是数字，string，Boolean类型的话
它内部是用value进行维护的


使用方法：
1.import { ref } from “vue”

2.let counter = ref （100）；
这样子就变成了一个ref的可响应式的引用

3.取值的的是用，再模板的时候使用ref对象的时候，他会自动进行解包，
就可以直接用counter ，本质上是counter.value 

所以再setup内部 就需要counter。value ++ ，只有模板才有自动解包的过程

### ref补充内容
如果变成了一个对象 及 info {
  counter = ref （100）
}，
那就要加上。value 即info。counter。value


如果是reactive包裹的对象，就不需要解包  
  reactiveInfo。counter



### readonly

readonly也是vue的一个api需要导入，
希望被使用但是不希望被修改
readonly会返回一个proxy（代理），但是会劫持一个set操作，防止被修改

使用方法：
1.导入
2.引用readonlyInfo = readonly(info);
，，如果进行修改，就会警告


注意事项：
1.如果是普通对象的话就会提升警告

2.如果是响应式的对象也会报警告不会被修改，一般传入的是一个子组件，用的是响应式 reactive

3.如果是ref对象响应式对象
ref内部对象是用refimpl对象实现的。
readonlyInfo3.value不可以改变属性，但是
如果是info.value 就可以改变


#### hook 钩子

## composition api
### reactive判断api这些api都系要从vue导入
#### isProxy（是否是代理）
isProxy检查是否由reactive或者是readonly创建的proxy

#### isReactive
检查是否由reactive创建的响应式代理：
如果该代理是readonly创建的，但是包裹了由reactive创建的另一个代理，它就会返回true


#### isReadonly
判断是否是由readonly创建的制度代理


#### toRaw
返回reactive或者readonly代理的原始对象 ，不建议保留对原始对象的持续引用，谨慎使用



#### shallowReactive
浅层的reactive，，它跟踪其自身的property的响应性，但不执行嵌套对象的深层响应式转化（指的是深层还是和原来的一样）


#### shallowReadonly
创建一个proxy，使其自身的property为只读，但不执行嵌套对象的深度只读转换（意思是深层还是可读可写）



### ref api补充   toRef和toRefs 

一般是响应式对象做解构的时候才会用到这个api
如果直接进行解构相当于是把值直接赋值过去的并不会让它变成响应式的

toRefs这个是把所有reactive对象的所有属性都转化为ref建立链接
如果从reactive直接结构出来
const info = reactive（{name:"why",age:18}）
let {name,age} = toRefs（info）;



使用方法：
1.导入toRefs
2.使用解构的方法


toRef  只转换某一个ref属性建立连接

使用方法：
导入toRef
let age = toRef(info,"age")，不需要加大括号进行结构了
上面的那个解构就需要加大括号。

#### unref
如果想获取ref引用中的value，相当于
val = isRef（val）？val.value:val

### isRef
判断是否是ref

### shallowRef
浅层ref

### triggerRef
手动触发和shallowRef相关联的副作用，用了shallowRef，如果还想触发响应式就用triggerRef

### customRef
自定义ref
它需要一个工厂函数，该函数接受track和trigger函数作为参数，
并且应该返回一个get和set对象

所有方法
1。新建一个js文件

2.导入customRef，定义一个工厂函数
track 收集，trigger设置更新

'''
export default function(value，delay = 300){
  let timer = null；
  return customRef((track,trigger)=>{
    get{
      track();
      return value;
    },
    set{
      clearTimeout（timer）；
      timer = setTimeout(() =>{
        value = newValue;
      trigger（）;},delay);
      
      ///设置更新延迟以及防抖,当你一直输入的时候他会不更新,delay设置一个默认值
    }
  })

} 
'''

## computed和watch
这个也需要import导入才可以使用，和ref一样常用
computed计算属性,相下面那样子写才可响应式，不然就是简单的赋值，返回的是一个ref对象
'''
setup（）{
  const firstName  = ref("Kobe");
  const lastName = ref("Bryant");
  //1.传入一个getter函数，返回值是一个ref对象
  const fullName = computed(()=>{firstName.value + lastName.value});
  //2.传入对象 设置getter和一个setter，返回的也是一个ref对象
  //const fullName = computed({get:() => firstName.value + lastName.value},set(newValue){
    const names = newValue.split(" ");//以空格分隔
    firstName.value = names[0];
    lastName.value = names[1];
  });
  const changeName = () = >{
    fullName.value = "xixi xixi"
  }
  return{
    fullName,
    firstName,
    lastName
  }
}
'''

### 侦听数据的变化
都需要从vue导入
再composition API里面由两个东西可以完成响应式数据的侦听

1.watchEffect，用于自动收集响应式的数据的依赖
用法：
导入之后用watchEffect//效果，影响
是一个函数可以直接传入回调
watchedEffect(()=>{
  console.log("name",name.value);
})
他会自动调用，它是默认一开始就会执行一次监听


停止侦听，当数据到了xx的时候想要停止侦听
这个computedEffect会一个返回函数，当达到条件时，调用这个函数就可以停止监听
const stop = watchedEffect(()=>{
  console.log("name",name.value);
}，{flush:"pre,post,sync不建议使用"})//watchEffect第二参数就是可以设定先执行
 pre就是在dom挂载之前执行完那段代码，post就是在dom挂载完之后执行就不会执行null

const changeAge = () => {
  age.value++
  if (age。value>25){
    stop()；
  }
}


清除副作用
当我们请求了网络数据还没返回的时候，然后用户又点，这时候需要用到清楚副作用以防造成资源浪费
就是重复发的时候就把上一次的请求清除
const stop = watchedEffect((onInvalidate)=>{
  const timer = setTimeout(() => {console.log("网络请求成功~")},1000)

    onInvalidate(() => {
    clearTimeout(timer)
    request.cancel()
  })
  console.log("name",name.value);

})
传的时候会给形参赋值,然后可以通过调用形参里面的request。cancel就可以取消请求

英文补充hook钩子


### setup中使用ref
以前使用ref，通过一下方法获取标签里面的值
'''
<h2 ref="title">haha</h2>
在export default {
   setup(){

   },
   methods: {
     foo(){
       this.$refs.title
     }
   }
}
 '''
现在在setup中使用不能使用this所以不能用以上做法
'''
在export default {
   setup(){
      const title = ref(null);//默认情况绑定null
      return{
        title
      }

   }
   '''
   如果想直接取值不显示null，就用flush齐平地：“post”等挂载完之后执行


   //通过以上操作就可以直接将上面的值赋给定义的title ，需要上面的东西挂载完了才可以赋值




2.watch，需手动指定侦听的数据源
懒执行副作用
更具体说明当前哪个状态发生变化触发侦听器执行
访问侦听状态变化前后的值



侦听单个数据源
导入
使用方法：
@click="changeData"

const info = reactive（{name：“why”，age：18}）
watch一般传入两个参数，有时候也传入三个参数，（对象，（newValue，oleValue）
侦听的对象可以直接写入一个ref对象，如果是reactive对象的话就需要进行某种转换

watch传入的数据类型有两种 ，一种是一个getter函数，但是该函数必须引用可响应式的对象比如ref或者reactive

第二种是直接写入一个可相应对象

1.watch(() =>info.name,(newValue,oldValue)),第一种写法
const changeData = () => {
  info.name = "kobe"
}
return{
  info
}


2.直接写入可相应对象，一般是ref对象


传入reactive对象时，获取的是reactive对象proxy
如果希望取到的是一个普通的对象就通过
'''
watch(() => return({...info}),(newValue,oldValue) => {
  console.log("newValue:",newValue,"oldValue:",oldValue)
})
'''
上面就是() =>({...info})，把整个当成箭头函数返回值


传入ref对象的时候，获取的时候就是value值得本身，拿到的是一个普通的对象，就是直接拿到里面的值
'''
watch(info,(newValue,oldValue) => {
  console.log("newValue:",newValue,"oldValue:",oldValue)
}),拿到的值
'''


### watch侦听多个数据源对象
传入值的时候可以传入数组，
wacth ([],(newValue,oldValue))

### watch 其他选项深度侦听
如果用reactive默认是深度侦听

如果是用普通对象的方法侦听的时候就不会进行深度侦听
() =>({...info})
，需要在后面传入第三个参数，{deep : true，immediate : 立即执行 true }

## 生命周期钩子
setup可以代替生命周期钩子
需要通过vue导入一些其他生命周期钩子
并且可以注册多个生命周期
created和beforeCreate直接在setup里面写就行
使用方法
'''
import { onMounted,onUpdated,onUnmounted } from "vue"
export default{
  setup(){

    const counter = ref(0);
    const increment = () => counter.value++//验证一下箭头函数
    onMounted(() =>{
      console.los('onMounted');
    })
    onUpdated(() =>{
      console.los('onUpdated');
    })
    onUnmounted(() =>{
      console.los('onUnmounted');
    })

  }}
'''

## provide提供inject注入
使用方法：父组件给子组件提供数据的时候,如果是直接的话用的是props比较方便
父：
import { provide ref readonly } from  "vue" ； 
export default {
  components: {home},
  setup(){
    const name = ref("xixi");
    let counter = ref(100);   //不是响应式的，能用ref尽量用ref
    provide("name",readonly(name));//为了遵守单向数据流的原则，防止子组件直接修改内容，需要用readonly进行传出数据的包裹,使用provide尽量使用readonly进行包裹
    provide("counter",readonly(counter))
  }
}
子：
import { inject } from "vue"
export default{
  setup(){
    const name = inject("name");
    const counter = inject("counter");
  }
  return{
    name,
    counter
  }
}

## 计数器案例
composition api的优点
1.传统方法
export default(){
  data(){
    return{
      counter:0
    }
  },
  computed:{
    doubleCounter(){
      return this.counter*2
    }
  }
},
whatch


2.使用composition//构成，组成 api
import { computed ref } from 'vue'
export default{
  setup(){
    const counter = ref(0);
    const doubleCounter = computed(() => {computed.value*2});
    return{
      doubleCounter,
      counter,
    }
  }
}

然后创建一个新的js文件，将上面的内容复制到那个文件中
'''
import { ref，computed}
export default function(){
const counter = ref(0);
    const doubleCounter = computed(() => {computed.value*2});
    return{
      doubleCounter,
      counter,
    }
}

'''
最后在setup中引入就可以了,上述返回的属性就可以在调用的时候被使用
import useCounter from 'xxx'
setup(){
const {doubleCounter，counter} = useCounter();
return{
  doubleCounter,counter
}
}
也可以使用return{ ...useCounter()}


## uesTitle案例
用法修改title，document.title就可以修改title，但是要更好的使用title需要通过
创建hooks文件夹，放入一个useTitle.js
useTitle.js:
import { ref,watch } from 'vue';
export default function(title = "默认的title") {
  const refTitle = ref(title);
  watch(refTitle,(newValue,oldValue),{immediate:true})
  return refTitle

}


App.vue:
import useTitle from './hooks/useTitle'
export default{
  setup(){
    const refTitle = useTitle("woshititile");
    settimeout(() => {
      reftitle.value = "my name is title"
    },3000)
  }
}

##  useScroll
查看当前网页所在位置
'''
<template>
div scroll/卷轴,滚屏滚动,div scrollx,scrolly    scrollx:{{scrollx}}
</template>
<script>
  import { ref } from 'vue';
  export default {
    setup(){
      const scrollx = ref(0);
      const scrolly = ref(0);//添加监听事件
      document.addEventListener('scroll',()=>{
        scrollx = window.scrollX;//查看当前网页的滚动位置
        scrolly = window.scrollY;
      })
    }
  }
</script>
<style scoped>
  .scroll{
    position : fixed//在右下角指定一个小框框显示网页滚动位置
    right:30px;
    bottom:30px;
  }
</style>
'''
也可以单独抽取出来类似于上面那样写一个hooks
'''
useScrollPosition：
import {ref} from 'vue';
export default {
  const scrollx = ref(0)；
  const scrolly = ref(0)；
  document.addEventListener("scroll",() =>{
    scrollx = window.scrollX;
    scrollx = window.scrollY;
  })
  return{
    scrollx,scrolly
  }
}

{{scrollx}}
app.vue:
import useScrollPosition from './hooks/useScrollPosition';
export defatlt{
  setuo(){
    const{scrollx,scrolly} = useScrollPositon()
  }
}
'''

## useMouse
大体步骤和上述滚屏的类似，主要是监听事件获取方式变成了,监听鼠标一般用的是window，
'''
window.addEventListener("mousemove",(event) => {
  mousex = event.pageX;
  mousey = event.pageX\Y;
})
'''
其他步骤都和滚动屏幕操作相同


## useLocalStorage本地存储
引入的用法与之前几个案例相类似
useLocalStorage：
import { ref,watch } from 'vue';
export default{
  setup(){
    const data = ref(value);
    if(value){
      window.localStorage.setIem(key,JSON.stringify(value));//如果有穿值就保存
    }else{
      data.value = JSON.parse(window.localStorage.getItem(key));//如果没有传值就设置
    }
    watch(data,(newValue,oldValue) =>{
      window.localStorage.setItem(key,JSON.stringify(newValue));

    },{
      immediate : true
    })
    return{
      data
    }
  }
}

可以将很多的hook封装到一个index.js文件中
import useStroge from ' '
import useMouseMove



export{
  usestroge,
  useMouseMove
}

app.vue:
import {usestroge,
  useMouseMove}from './index.js'


### 实验性的特性
<script setup>
  可以将代码直接写到这里边不需要return值
</script>

## props emit 
props 子组件定义，app里面组件传message给子组件，
emit  子组件发送，传给app。vue接收。


### 组件化高级特性h函数
h函数和render（提供）函数
vue推荐大多数情况下用模板完成创建html，template=>vnode（虚拟节点）=>element
render函数需要返回一个vnode函数
render(){return vnode}，
这时候用h函数就可以可以不用创建vnode函数，更准确的可以说是createVNODE函数
h函数有3个参数第一个参数放标签，第二个参数放id，class，第三个参数放元素或者内容


## render函数的使用
通过render函数就不需要写模板了
'''
import { h } from 'vue';
export default{
  render(){
    return h("h2",{class : "title"},"hello render")//通过h函数就可以返回一个vnode
  }
}
'''

模板字符串用方法  `当前计数：${this.counter}`在render里面就可以使用this拿值

setup也可以写render，需要在return里面返回上面的h，且不能用this要加。value


### render中插槽和组件使用
直接引入就可以不用注册

render(){
  return h(HelloWorld,nill,[]/{})//传入多个可以用数组或者对象


}

app传入一个插槽{default props =>h()}
this.$slots.default?this.$slots.default():h("span",null,'"我是默认值")'


## jsx的Babel配置jsx初体验
如果当前脚手架版本不支持jsx语句就

react编写的就是用jsx通过Babel转换
'''
<script>
  export default{
    data(){
      return{
        counter : 0
      }
    },
    render(){
      return (<div>
              <button onClick = {this.counter}></button>//获取点击事件用的是onClick,并且=后面用大括号，这就是jsx的语法
              <h2>当前计数：{this.counter}</h2>
             </div>)
    }
  }
  </script>
  '''
  以上就是jsx代码

传一个插槽给子组件
App.vue:
render(){
return(<HelloWorld>
        {{default:props =><button>我是按钮</button>}}
      </HelloWorld>)
HelloWorld：
this.$slots.default?this.$slots.default():<span>哈哈哈</span>
}



## vue 3 高级语法
如果需要对DOM元素进行底层操作，就需要用到自定义指令

### 自定义指令分为两种
1.directives（指针指令）自定义局部指令
2.app中的directive方法，自定义全局指令


### 自动获取焦点案例
当网页加载完自动获取焦点
用onMounted,然后直接调用input.value.focus()
即可在网页加载完之后自动获取焦点

可以将它包装成一个自定义指令或者用默认的方法导入，
自定义指令直接在input里面加一个v-focus
<input type="text" v-focus>

1.局部的指令
'''
directives：{
  focus：{
      //一般定义这个指令的生命周期
      mounted(el,bindings,vnode,preVnode){
        console.log("focus.mounted")
        el.focus()//直接拿到元素调用focus就可以使用以上方法进行局部调用
      }
  }
}
'''

2.全局指令
与上面思路差不多
app.directive("focus",{放入上面的方法就可以实现全局指令的操作})


### 指令的生命周期和参数修饰符
created：在绑定元素的attribute或者事件监听器被应用之前调用
beforeMount：当元素挂载之前
mounted：挂载后调用
beforeUpdate：在更新之前
updated：在包含组件的VNode及其子组件的VNode更新调用之后
beforeUnmount：卸载绑定元素之前
unmounted：当指令与元素解除绑定且父组件已卸载时候，调用一次


自定义指令可以有修饰符以及参数

mounted(el,bindings,vnode,preVnode)

修饰符都是放到bindings里面,el放元素，bindings放修饰符

### 时间戳的显示需求
获得一个时间戳，然后将 时间戳转化为时间，vue3已经删除了filter
对事件进行格式化，可以用filter，method，computed
可以使用v-format-time自定义指令进行格式化时间戳

directives,index.js
import dayjs from 'dayjs';
format-time.js:
'''
export default function(app){
  app.directive("format-time",{
    mounted(el,bindings){
      const textContent = el.textContent;
      let formatString = bindings.value;//也可以在created中写这些代码用于初始化
      if (!formatString){
          formatString = "YYYY-MM-DD HH:mm:ss"
      }
      const timestamp = parseInt(textContent);
      if(textContent.length === 10){
        timestamp = timestamp * 1000 //时间戳10位的是秒位单位，11位是毫秒位单位所以转化为毫秒
      }
      el.textCountent = dayjs(timestamp).format("formatString");//可以直接用dayjs库转化,小写hh是12小时制，HH是24小时制
    }
  })
}

'''



### vue3 Teleport内置组件
如果封装了a组件，在另一个组件b中使用
那么组件A中的template元素就会被挂载到b组件的某个位置
最终应用程序就会形成一个DOM树结构
如果不想挂载到组件树上，可能移动到vue app之外


它是一个内置组件，类似与react的portals
teleport//远距离运输

它有两个属性：
1.to ：指定其中的内容移动到目标元素
2.disabled：是否禁用teleport的功能

使用方法：
<teleport to="xxxx">内容</teleport>
把我们要传的内容
to表示移动到的位置



## vue插件
1.对象类型里面必须有一个install函数，新建一个js，然后通过import导入main。js，然后使用app。use（xxx）
export default{
  install(app){
    console.log(app)
    app.config.globalProperties.name = "coderwhy"//这是一个对象，可以给它传入属性和值，若怕冲突可以在name加一个$,
  }
},
如果在要setup里面拿需要通过一个getCurrentInstance组件，然后instance.appContext.config.globalProperties.$name.通过这个操作才可以在setup里面取到上面的值
使用方法：使用在全局app.use(pluginuse)
2.函数类型

功能：
1.添加全局方法或者property，通过把他们添加到config.globalPropertier
2.添加全局资源
3.通过全局mixin添加一些组件选项
4.一个库，提供自己的API，同事提供上面提到的一个或者多个功能

## 如今开发模式
前后的分离阶段
SPA开发：simgle page application
category种类
前端映射关系：路径-组件
### 前端路由
### URL的hash也就是锚点#，
href#/
href"/#"就会打开一个带有hash值得一个url并且不会发生跳转，

hash值的变化可以通过window.addEventListener("hashchange",() =>{
  console.log(location.hash);
  case'#/home':contentEL.innerHTML = "home";//判断hash值为#/home情况下
  default:contentEL.innerHTML = "DEfault"//设置默认值
})
获取元素练习 ：
const getel = document.querySelector('content');

路由实现原理，是通过监听hash的改变，然后修改相应的界面


### HTML5的history 
### BOM//Browser Object Model浏览器对象模型
### DOM///Document Objecct Model文档
history的方法：
1.replaceState:替换原来路径
2.pushState：使用新路径
3.popState：p路径回退
4.go：向前或者向后改变路径
5.forward：向前改变路径
6.back：向后改变路径//语法补充demo：演示，实验，示范


### history-demo
获取元素的方法：
document.getElememtByTagName("a");
document.getElementById("#")
获取a元素
document.querySelectAll
document.querySelect

监听加遍历案例：
for(let a of aEls){
  aEl.addEventListener("click",e =>{    //e为回传的对象，此案例为a标签
    e.preventDefault();//阻止默认事件
  })
}



获取元素路径的方法：
const href = aEl.getAttribute("href");
获取href里面的值
history.pushSate({},"",href);//接收3个参数，可以去查文档
这样子就可以跳转路径但是又不去服务器请求，这样子返回的界面就可以通过前端进行编写


## vue-router深度解析

每个框架都有组件的路由实现：Vue Router是Vue.js的官方路由，vue-router是基于路由和组件的，将路径和组件映射起来，在vue-router的单页面应用中，页面的路径就是改变组件的切换


安装路由：
npm install vue-router@4默认是创建3版本的所以我们要自己指定

使用步骤：
在router文件夹里面建一个index.js,在这里面配置
1.创建路由对应的组件
2.通过createRouter创建路由对象
3.配置路由映射
'''
import { createRouter,createWebHistory,crateWebHashHistory } from 'vue-router'
//配置映射关系
const routes = {
  { path:"/home",component:Home }
  { path:"/about",component:about }
  { path:"/xixi",component:xixi }
}
//创建一个路由对象
const router = createRouter({
  routes,
  history:crateWebHashHistory()          //模式
})

export default router
'''

然后就导入main.js里边
const app = createApp(App)
app.use(router)////返回的也是一个App
app.mount(#app)


### router-view和router-link
vuerouter给我们提供了一个内置组件router-view用于放置组件的位置,占位的关系
<router-view\>
想要两个路径切换
可以设置按钮，设置router-link
<router-link to="/home">////默认情况下是A元素
<router-link to="/about">



### router补充细节
### 默认路径
补充默认路由，当路径是/的时候
{ path:"/",rerirect: Home },这样默认就显示首页，
开发里面用的是重定向
redirect


### history模式
使用history就重新创建模式


### router-link
to属性：是一个字符串或者对象


replace属性：设置replace属性的话，点击的时候就会调用router.replace，这样子就不可以进行压栈的操作


active-class属性：默认是A元素
默认为router-link-active,可以给它添加对应的样式
需要改的话需要把全部都改了，active-class = “xxx”
,之后我们修改样式的时候就需要用。xxx修改


exact-active-class属性：
链接精准激活时，用于渲染a的class，意思是就是/home/shops中两个链接匹配，就会加到子组件里面exact-active-class。


tag属性已经被删掉了



### 路由懒加载
打包的时候异步打包，另外打包
### 魔法注释
在路由配置中，magic comment  webpack魔法注释，可以通过这个告诉名字
import(/* webpackChunkName: "home-chunk"*/"../pages/Home.vue")//////  
/* webpackChunkName: "home-chunk"*/用此方法就可以给包起名字
'''
routes{

  {path："/home"，component:() =>{
    return import('../pages/Home.vue')   //() =>import("../pages/Home.vue")简写方式，少了return和大括号
  }}
}
'''

### 异步打包回顾
import(""../pages/Home.vue).then(res =>{

})

### routes属性补充
routes {
  {path:"home",
  name://加名字
  meta://可以加一些数据
  }
}


### 动态路由基本匹配
1.{
 path:"/user/:username",也可以添加多个参数，例如id，meta，name等:id
 component:() =>import("../pages/User.vue")
}


2.<router-link to="/user/name/id/111">,//即传入名字也传入了id为111的值
如果要动态绑定用v-bind 
<router-link :to="/user + 'name'">


如何获取name
params参数
可以在生命周期里边
{{$route.params.username}}动态获取使用者名字
created(){
  this.$route.params.username
}

setup里面拿值得话
4版本以上
可以提供一个useRoute
import from 'vue-router'


cost route = useRoute();
router.params.username
就会返回我们要显示的那个路由对象,setup在created之前执行的



### 若路径错误的动态路由匹配
'''
{
  path:"/:pathMatch(.*)*"///括号里边是正则意思是匹配所有后面多一个*就会以数组进行分割
  component:() => import("../pages/NotFound.vue")//我们可以自定义一个vue来展示如果用户搜索不到相对应的路径展示的东西所展示的东西
  //component: () => //可以直接输入代码了

'''

获取用户输入的路径：{{$route.params.pathMatch}}


### 路由嵌套


一个页面里面再嵌套一些组件，就用相对应的嵌套组件里面配置children
在home组件里边再存几个组件，message和shops组件
router-link to="子组件地址"

{
  path："home",
  children:[{
            path:"message",
            component:() =>import("../pages/homeMessage.vue")
             }
            {
            path:"shops",
            component:() =>import("../pages/homeShops.vue")
             }
            ]
}
然后配置映射关系

exact-active-class属性：
链接精准激活时，用于渲染a的class，意思是就是/home/shops中两个链接匹配，就会加到子组件里面exact-active-class。




###  编程式导航
通过按钮跳转，
1.设置一个按钮
2.写一个methods，拿到点击事件，通过代码进行跳转
拿到router对象，有两种方式，1导入router不推荐，2用this.$router拿到router对象
，用this.$router.push("/home")///直接输入地址就可以指定到那个地址，

3.在setup里面，compositionAPI里面，我们不可以用this，导入一个{useRouter} from 'vue-router'.
然后直接使用这个对象就可以了
const router = useRouter();
const jumpToAbout = () => {
  router.push("/about")//push是用于跳转
}，

router.replace//替换
router.go(1) ///表示前进一步
router.back(1) //表示后退一步，也可用-1表示前进一步
其他操作跟上述类似，也可以传入对象
push(path:"/about",
      query:{
        name:"why",
        age:18
      }//query里面的参数是传输到路径上的查询字符串
)


明日课程
router-link的v-slot
router-view的v-slot
动态添加路由
导航守卫


### router-link
补充原来的tag已经被删除，在vue-router4已经被删除了
现在通过插槽的方式进行渲染，直接
#### props属性
'''
<router-link to="/home" v-slot="props" custom>
//1.props里面有href跳转的连接,如果想要把a元素去掉在后面加一个custom

//2.{{props.href}},还会传递route对象，props.route,props.navigate//导航函数，
3.button @click="props.navigate",通过这样子button就可以直接跳转到上面的连接，就不用去去获取router.push 去写
4.props.isActive是否处于活跃状态//用于判断当前是否处于活跃然后添加相关样式
例子//span :class="{'active':props.isActive}"{{props.isActive}},这样子就可以给span添加相对应的样式
5.isExactActive:是否精准匹配，精准匹配就是地址前两位一样
//在这里放什么，到时候就会在a元素里显示一个你想写入的内容，也可以放入一个组件
</router-link>
'''



### router-view的v-slot
'''
<router-view v-slot="props">//props放的是各种对象属性，拥有和上面一样的属性，用法一样
{{props.Component}}
<transition>
<keep-alive>
<component :is="props.Component"></component>//表示到时候属性是谁就显示哪个组件
</keep-alive>
组件缓存，用keep-alive防止不断新建造成资源浪费
</transition>///添加相对应的动画效果
</router-view>
'''
动画学习补充
.class-enter-active,.class-leave-active{transiton:opacity 1s ease;}
enter-alive表示整个进入动画都存在的  

### 动态添加路由
用于权限管理实现不同页面的展示
router.addRoute({
  path:"/order",component =>import("")
})

'''

const categoryRoute = {
  path:"/category",
  component:() => import("../pages/Category.vue")
}
if加上判断就可以动态添加
//添加顶级对象
router.addRoute(categoryRoute)
//添加二级路由对象
router.addRoute("home",{
  path:"moment",
  component:() => import("../pages/HomeMoment.vue")
})
'''

通过以上方法可以动态添加路由不把这个方法写在route数组里边，实现动态添加路由对象，也可以进行嵌套


### 动态删除路由
三种方式
1.router.addRoute({path:'/about',name:'about',component:About})
  router.addRoute({path:'/other',name:'about',component:Home}),
  添加一个名字相同路径不同的路由就会删除前一个替换

2. router.addRoute({path:'/about',name:'about',component:about})
    router.removeRoute('about')

3.通过addRoute的方法返回值回调
const removeRoute = router.addRoute(routeRecord)
removeRoute()//删除路由，如果存在的话


### 路由其他方法补充
router.hasRoute():检查路由是否存在
router.getRoutes():获取一个包含所有路由记录的数组


### 路由导航守卫
有很多种守卫可以在vue官网进行查看
有完整的导航解析流程

用于判断是否跳转，做拦截的时候
router.beforeEach((to,from) =>{
  //进行路由跳转的时候会执行
  //return false就不会进行跳转进行拦截
})

回传的两个参数：
to是一个route对象，表示即将跳转到的route对象
from表示从哪过来的
next在vue-router4开始不推荐使用了，容易出错

通过以此即可判断
if(to.path === "/home")
进行拦截判断
如果需要用到next，用到的就是返回值，
return：
1.false，就是不进行导航
2.undefined或者不写返回值，表示进行默认导航
3.可以返回字符串，路径，写啥路径就会跳转到哪个路径中
4.返回一个对象router.push({path:"/login",query:......})

### 登陆界面登陆后防止回跳登陆界面

可以给本地缓存一个值
window.localStorage.setItem("index","i");
然后进行判断
const index = window.localstorage.getItem("index")
if(!index){
  return "/login"

}


## vuex的状态管理
1.data和setup中的数据，我们成为state
2.模块中的template最终会被渲染成DOM，我们称之view
3.当行为view变化时会修改state，我们称之actions


vuex对象管理状态：vue devtool
将组建内部状态抽离出来，以一个全局单例的方式来管理

Vuex借鉴了Flux,Redux,Elm
multation不允许有异步请求
所有在action中提交异步请求

### vue devtool
算是chrome的一个插件，是vue官方开发的，用的是6.0.0beta15的版本，支持vue3
安装vue dev-tool
两种安装方式

### 使用vuex
1.install vuex@next
2.store//仓库建立一个文件夹
然后新建一个index.js
3.导入 
import { createStore } from 'vuex'
const store = createStore({
  state(){
    return{
      counter:0
    }
  }，
  mutations:{
        increment(state){},//会传来一个state，在这里面进行操作不可以直接在methods修改
        decrement
  }
})
export default store


练习：在index.js里面写这个代码
import {createStore} from 'vuex'
const store = createStore({
  state(){
    return{
      counter:0
    }
  },
  mutations:{
    increment(state){
      state.counter++
    }

  }
})

在main.js里边
import store from 'vuex'

createApp(App).use(store).mount("#app")

安装仓库，
在main的js导入使用store，然后use(store)
4.option API

<h2>{{$store.state.counter}}</h2>
在methods：{
  increment(){
      在组建里要修改需要通过mutation实现
      this.$store.commit("increment")//需通过this.$store.commit提交

  }
}



## 前端学习方向
 vue - 小程序（uniapp/taro） - node - react - webpack - 数据结构算法 刷一下leetcode对于面试有帮助


 ### vuex 组件中使用Store

 ### mapState
 它是一个函数，返回一个对象
 使用方法：
 导入
 然后再computed：{
      ...mapState(["counter","name","age"])
      通过这样子获取数组写法
      mapState({sCounter:state => state.counter})
      对象写法用于自定义名字
 }

### mapState 在setup里面用
 载setup里面使用
 导入useStore和mapState
 computed导入
 setup(){
   const store = useStore()
   const sCounter = computed(() => store.state.counter)
  const storeState = mapState(["counter","name","age","height"])
   return {
      sCounter
      ...storeState
   }
 }

### 在setup里面获取多个对象方法
const storeState = {}
Object.keys(storeState).forEach(fnkey => {
  const fn = storeState[fnkey].bind({$store:store});
  storeState[fnkey] = computed(fn)
})


### 封装上面代码,以后获取vuex里面的函数就可以用这个
在src上面创建一个hook文件夹封装常使用的函数
useState

import { mapState,useStore } from 'vuex'
export function useState(mapper){
  const store = useStore()
  const storeStatefns = {}
  Object.keys(storeStatefns).forEach(fnkey => {
  const fn = storeStatefns[fnkey].bind({$store:store})
  storeState[fnkey] = computed(fn)
})
  return storeState
} 


然后用useState就可以更加方便的获取到我们需要在setup里面获取的值了

### getters的基本使用
'''
在store的index.js配置
const store = createStore({
  state(){},
  mutation:{},
  getters:{
    //在这里面计算属性的值,可以传入两个参数，第二个参数可以是另一个getters
    totalPrice(state,getters){
      let totalPrice = 0
      for(const book of state.books){
        totalPrice += book.count * book.prive
      }
      return totalPrice //*getters.currentDiscount也可以配合其他getters使用
    }
  }
})
'''

## vuex五大核心
state，getters，mutations（变动），actions，modules

某些属性需要变化之后使用，这时候就用getters，跟computed比较像
使用方法：
$store.getters.totalprice//最后面就是你自己定义的计算属性


getters的另外一种用法
'''
return 一个函数，然后函数里面加入判断的逻辑
//return  function(n){
 //   if xx n
}
//return totalPriceCountGreaterN
'''
调用这个getters的时候就需要加多一个括号表示调用

如果template里面太多判读那语法可以放到computed里边

##  ...mapGetters

'''

<template>
    <h2>
        {{nameInfo}}
    </h2>
</template>

'''

使用方法 导入mapGetters



然后用计算属性

computed:{

 ...mapGetters(["nameInfo","ageInfo"])

}

也可以输入对象{sNameInfo:"nameInfo"}

和state写法不同 state是通过一个 mapState({sCounter:state => state.counter})



用composition api使用mapgetters



setuo(){

const store = useStore()

 const sNameInfo = computed(() => store.getters.nameInfo)//传统做法

}



封装函数做法

const storeGettersFns = mapGetters(["nameInfo","ageInfo"])



与上面封装的storeState思路一样



上面两个函数可以将两份东西合并成一个

不同的方法可以用传入的参数代替



## mutation

更改vuex里面的State的唯一方式

this.$sotre.commit("increment"，{})//开发中一般是传入的是对象，这样子就可以传入一些复杂的数据

另一种提交风格

this.$store.commit({

type:'increment',

n:10,

name:"why"

})

提交的时候可以传入参数在sotre的index.js

increment(state,payload){

 state.counter += payload

}

一样的名字可以写成常量，一般就用大写INCREMENT_N,然后抽到一个文件里面导入使用

### mutation细节补充

1.内部提交mapMutation

使用方法导入

'''

<button @click="INCREMENT_N({n:10})"></button>


'''

export default{

methods:{

 ...mapMutation(["increment","decrement","INCREMENT_N"])//通过此方法就可以不用单个提交

this.$store.commit("increment({n:10})"),

}

}







composition api使用方法

setup(){

const storeMutations = mapMutations(["increment","decrement","INCREMENT_N"]) 

 return{

 ...storeMutations    

}

}

## actions 五大核心之一的基本使用
加层因为mutation不可以有异步操作，所以vuex增加了一层action
用法类似于mutation
action提交的是mutation而不是直接提交状态
action可以包含任意异步操作
context和store有相同的方法和属性

在store的index.js里面编写
actions：{
  incrementAction(context,payload){//也可以传入对象结构{commit,dispatch,}
    context.commit("increment")//t提交context里面的属性，dispatch,getters,rootGetters,rootState,state
    //dispatch也可以使用dispatchother的actions跟getters一样可以调用其他的getters
  }
}


 调用actions,可以进行异步操作,调用actions用dispatch,也可以传入参数，然后可以进行操作
Home.vue
methosd:{
  increment(){
    setTimeout(() =>{this.$store.dispatch("incrementAction")},1000)
   // 派发风格：对象类型this.$store.dispatch({type:"decrementAction"})
    
     }
}

两种方法 option api 和composition api
1.导入axios,下载导入
mounted(){
  axios.get("http://").then(res =>{
    console.log(res)
  })
}

### mapActions
跟上面的其他方法一样
导入
...mapActions(["incrementAction","decrementAction"])
...mapAction({
  add:"incrementAction",
  sub:"decrementAction"
})



composition api
setup(){
  const actions1 = mapActions(["incrementAction","decrementAction"])
  const actions2 = mapActions({
      add:"incrementAction",
      sub:"decrementAction"
  })
  return {
    ...actions1,
    ...actions2
  }
}

若想在mounted中使用异步操作，最好通过setup的onMounted，不直接用mounted


## actions返回值
actions默认返回值是undefined
可以返回一个promise，然后再子组件中就可以观察是否发送请求成功
使用方法
1.actions里面
return new Promise()
axios.get("").then(res =>{
  context.commit("addBannerDate",res.data.data.banner.list)
}).catch(err =>{reject(err)})

在组件里边,就可以拿到actions里面传的东西
promise.then(res =>{

}).catch(err =>{
  reject(err)
})


## module的基本使用
在store文件夹里面加多一个module文件夹，新建文件
通过export default到出，
他也有state，mutation，getters，actions，module
然后index.js里面可以写：
module:{
  home:homeModule
}

在子组件中使用
用$store.state.home.homecounter


## module提交事件
this.$store.commit("increment")，到时候会所有的increment都提交

module想要用getters里面的数据
需要通过$store.getters.doubleCounter,

如果想区分模块和本来的东西
需要在模块对象上加一个
### namespaced:ture,
然后取值，
取值方法：
getters：
用$store.getters["home/doubleHomeCounter"],获取getters里面的对象
state：
this.$store.commit("home/increment")
actions:
this.$store.dispatch("home/incrementAction")
需要增加上模块的名称


getters增加了命名空间多了很多参数,有4个参数需要用到的时候就去查一下
getters:{
  doubleHomeCounter(state,getters,rootState,rootGetters)
}

action有6个参数用结构的方法拿对象里面的方法
actions{
  incrementAction({commit,dispatch,state,rootState,getters,rootGetters}){
      commit("increment",null,{root:true})//表示根也提交，第二个参数表示传的参数
      dispatch("incrementAction",null,{root:true})
  }
}

context 的不同就是在module里面的参数多了两个rootGetters和rootState

### module的辅助函数
computed:{
...mapState(["home/homeCounter"]),
...mapGetters(["home/doubleHomeCounters"])
写法1：
...mapState({
  homeCounter:state =>state.home.homeCounter
})
...mapGetters({
  doubleCounter:"home/doubleCounter"
})
},
写法2：
...mapState("home",["homeCounter"])
...mapGetters("home",["doubleHomeCounter"])

methods:{
  ...mapMutation("home",["increment"]),
  ...mapActions("home",["incrementAction"])
}
写法3：
导入creatNameSpacedHelper from "vuex"
const {mapState,mapGetters,mapMutations,mapActions} =  creatNameSpacedHelper("home")

使用的时候：
...mapState(["homeCounter"])



在composition API中使用
可以使用之前封装的useState和useGetters加层判断
if有传值进来，然后判断是否有传值，有的话用creatNameSpacedHelper,


setup(){
  const state = mapState(["homeCounter"])
  const getters = mapGetters(["doubleHomeCounter"])
  const mutations = mapMutations(["increment"])
  const actions = mapActions(["incrementAction"])
  return{
    ...state,
    ...getters,
    ...mutations,
    ...actions
  }
}



### 自定义指令format-time bug 修复
需要把let formatString = "YYYY-MM-DD HH:mm:ss"
放到created里面，然后通过bingdings.formatString传到mounted里面进行挂载

初始化的东西最好放到created里面

自定义指令今晚试试实现

## nexttick
DOM改变完后，立马执行nexttick
onUpdated是公用的生命周期函数，不能针对性的

从vue导入

使用方法:
const addMessageContent = () =>{
nextTick(() => {
  console.log(titleRef.value.offsetHeight)
})
}

上述表达式就会在dom执行完后执行


nexttick原理：
浏览器的event loop实现循环  js从事件循环队列一个个执行，


微任务队列，先执行再执行宏队列，promise.resolve().then(回调函数)，watch，组建的更新，生命周期回调
宏任务队列 ，DOM ,setTimeout

vue执行各种队列
postQueue，preQueue,jobQueue，

nexttick(() =>{
  console.log
})
用这个就会把console加到微任务的最后面

### historyApiFallback:true
主要是解决spa页面在路由跳转后进行刷新返回404错误，
浏览器解析流程dns解析然后变成ip地址，去寻找相对应的ip地址
devServer中实现historyApoFallback功能是通过connet-history-api-fallback库的：
用try_files $uri $uri/ /index.html;
index index.html index.htm;
配置成true会默认返回根路径的/index.html


# TypeScript
微软推出的TypeScript
是拥有类型的JavaScript超集，它可以编译成普通，干净，完整的JavaScript代码
枚举类型Enum,元组类型Tuple，优点和es同步js有的他都有
编译的时候也不需要借助Babel

写TypeScript后转换成js代码，然后

特点：
始于JavaScript，归于JavaScript
可以在任何浏览器上运行，可以在node运行，在支持ECMAScript3的JavaScript引擎中


TypeScript初体验：
const message:string = "Hello World"
多了一个类型判断


运行环境 tsc：TypeScript compiler

安装npm install typescript
tsc --version
编写typescript代码，然后运行的时候
用tsc 加上文件名就可以编译这样子就可以防止代码出错


## 环境搭建
每个文件要当做单独的作用域
需要在最后面加一个export{},不然的话就是全局作用域，会导致代码错误

模块热替换HMR hot module replace
1.用webpack搭建ts环境
1.npm init
2.npm install webpack webpack-cli -D
4.创建webpack.config.js
导入配置:
const HtmlWebpackPlugin = require("html-webpack-plugin")

module.export = {
  entry:"./src/main.ts",
  output:{
    path:path.resolve(__dirname,"./dist"),//你不知道他有多少层
    filename:"bundle.js"
  },
  resolve:{
    extensions:[".ts",".cjs"."js",".json"]/需加上.js
  }
  modele:{
    rules:[
      {
        test:/\.ts$/,
        loader:'ts-loader'
      }
    ]
  },
  plugins:[
    new HtmlWebpackPlugin({
      template:"./index.html"
    })
  ]
}
5. npm install ts-loader typescript -D
6.tsc --init,会自动安装配置,生成一个tsconfig.json
7.安装一个webpack-dev-server -D，就可以不用修改的时候一直打包
安装完之后在package.json 的script里面写 "serve" ："webpack serve"
也可以在webpack 配置devserver
8.需要再安装一个html-webpack-plugin -D
9.在webpack配置

2.ts-node可以通过ts-node TypeScript直接运行 
使用方法：
1.npm install ts-node -g
2.依赖另外两个包：install tslib @type/node 
3.使用 ts-node 文件名.ts
4.ts默认导入不加路径，所以要加一个extensions//后缀名.ts表示扩展延申

### TypeScript变量的定义格式
string：在TypeScript表示字符串类型
String：在TypeScript表示JavaScript的字符串包装类类型



eslint =》js代码规范
tslint =》ts代码规范
全局安装
tslint --init

### 添加类型注解，ts特性类型推导
默认将赋值的值的类型当作赋值的类型
let foo = "foo"


### ts官网：typescriptlang.org


### number类型的使用
没有没有int double，flout型

进制：
let num1:number = 100十进制
let num1:number = 0b11100二进制
let num1:number = 0o100八进制
let num1:number = 0x100abcd十六进制
也可以用前缀表示进制

### Boolean类型
let flag:boolean = true
flag = false
只有true和false
flag = 20>30也可以用来判断

### string类型
let message1 = "hello world"

可以用模板字符串进行拼接
let message = `name:${name} age:${age}`


### array类型
 const names = []
 我们无法确认数组里面的类型，开发中存放的数据类型固定最好
 类型注解：type annotation
 const names:Array<string> = [],就表示数组里面传的必须是string
 推荐用
 const names:string[] = []这种方式更加适合


### object类型
const info = {
  name:"why",
  age:18
}他会自动推到相匹配的类型，

也可以自定义类型,最好自动推导出来


### null和undefined
null只有null

const n1: null =null
null最好使用:null

### symbol类型

const title1 = Symbol("title")
const title2 = Symbol("title")
const info = {
[title1]:"程序员"
[title2]:"老师"
}
export{}


## TypeScript类型
### any类型
某些情况下无法确定类型就可以使用any类型,
有时候进行类型断言的时候，转换类型的时候，先转换成any再转化成想要转换的类型
不想给某些JavaScript添加具体的数据库类型
有时候引入第三方库，缺失类型注解的时候
let message:any = "Hello World"
message = 123
message = ture
message = {

}

### unknown类型
用于表示不确定的变量
function foo(){
  return 123
}
function bar(){
  return "abc"
  }
let flag =ture
let result:unknown //防止拿到result就去其他地方乱用
if(flag){
  result = foo()
}else{
  result = bar()
}


export{}//表示块级作用域，不写的话要是其他文件也有就会报错


### void类型
function sum(num1:number,num2:number){
 console.log(num1+num2)
}
sum(20,30)

函数没有返回值，返回的就是void类型
如果是void类型就可以返回undefined或者是null，可以不写void类型


### never类型的使用
表示永远不会发生值得类型
函数死循环得时候就是函数不会返回东西
function foo() :never {
  while(){

  }
}

function bar() :never {
  throw new Error()
}

应用场景：never应用场景,联合类型
function handleMessage(message:string | number | boolean){
  switch(typeof message){
    case 'string':
     console.log("string处理message")
     break
    case 'number':
     console.log("number处理message")
     break
    default:
     const check: never = message
  }
}
防止增加类型之后忘记处理新增类型,如果新增了一个Boolean类型就会报错，所以加上Boolean类型的处理就可以防止报错

### tuple类型
元组类型：多元素的组合
const info: any[] = ["why",18,1.88]
如果想在数组传入数据这样子不安全

元组的特点
const info:[string,number,number] = ["abc",1,2]
const name = info[0]
console.log(name.length)
export{}

### tuple应用场景
很多时候传入多个参数用元组类型实用性更高，泛型<T>,将any都改成T，这样子输入什么就是什么类型


### 函数的参数和返回值类型
返回值类型加在括号后面
开发中通常情况下可以不写返回值，它会推导出来
function sum(num2:number,num1:number):number{
  returen num1 + num2
}


### 匿名函数的参数类型
function foo(message:string){}
const names = ["abc","cba"]
names.forEach((item) =>{
意思就是item里面可以不用指定类型，通过上下文可以推导出names的类型就可以不用添加类型
})


### 对象类型可选类型
function print(point:{x: number,y: number,z?:number}){

}
传入的参数就必须是一个对象且里边需要传入两个number的参数
z代表可选类型，没传值的时候是undefined，


### 联合类型
用|就是联合类型,用联合类型的时候要小心如果想拿到id来做操作
id.toUpperCase变大写,narrow缩小
function printId(id:number|string){
  if (typeof id ==='string'){
    console.log(id.toUpperCase())
  }else{
    console.log(id)
  }

}

printId(123)
printId("abc")




### 可选类型和联合类型
当一个参数是可选类型，本质上类似于这个参数是某个类型和undefined的联合类型
function foo(message?:string){
  console.log(message)
}
foo()

function foo(message:string|undefined){
  console.log(message)
}
foo(undefined)


### 类型别名type alias
type TnionType
type IDType = string|number
function printID(id:IDType)


### TypeScript其他类型补充as
### 类型断言as
1.
const el：HTMLElement = document.getElementById("why") as HTMLImageElement

el.src = "url"
2.
类案例，就是把子类对象传给父类，多态
class Person {

}
class Student extends Person {
  studying(){

  }
}
function sayHello(p:Persom){
  (p as Student).studying()
}
const stu = new Student()
sayHello(stu)

3.特殊情况下的转换
const message ="xixi"
const num:number = (message as unknow/any) as number

### 非空类型断言！
function printMessageLength(message?:string) {
  if(message){
    console.log(message.length)
  }
}
console.log(message!.length)//！表示一定有值，非空类型断言
printMessageLength("Hello World")
printMessageLength("哈哈啊")

可选类型message？ => undefined | string

若用上面的写编译的时候就会报错，因为这样子就不严谨，
最好的是类型缩小

### 可选链的使用
当对象属性不存在的时候会短路，如果存在才会继续执行
es11新增的特性?.
type Person = {
  name:string
  friend?:{
    name:string
    age?:number
  }
}
const info:Person = {
  name:"why"
  friend:{
    name:"kobe;
  }
}
如果要取值的时候要做太多判断
我们可以用可选链减少判断

使用的时候，用于friend，用它做断言的时候写到它后面
console.log(info.friend?.name?)
,如果没有的话就会返回一个undefined，如果没名字的时候可以在name后面加个问号,谁可能没值谁加问号，取值调用方法都可以用可选链



### ??和!!的使用
！！是将其他类型转化成Boolean类型
类似于Boolean方式
使用方法
1.
const message = "hellow world"
const flag =Boolean(message)

2.
const flag = !!message//如果一个！就是取反是false，如果再加一个！就表示转化为true 是JavaScript的特性

### ？？运算符
es11新增的新特性，空值合并操作符
let message:string | null = null

const content = message ?? "你好啊李银河"//意思是如果传的值位null，若不想让它显示为null就用？？设置默认值，？？后面的就是默认值

和三元运算符类似
const content = message ? message:"你好啊李银河"
就比？？方便一点



### 字面量类型
它的类型和它的值必须相同才可以，必须结合类型才有意义
let message = "hello World"
const是一个字面量类型
const message = "hello wOrld"


例：
type Alignment = "left" | "right" | "center"
let align："left" | "right" | "center" /Alignment


这样就只能给align赋值这3个值


### 字面量推理
为防止直接调用的时候报错
type Method ="POST" | "GET"
1.function request(url:string ,method:Method){}
2.const options = {
  url:"https.baidu.com",
  methods:"POST"
}as const

3.request(options.url,options.method as Method)//用断言

1.type Request = {//使用字面量类型
  url:string,
  method:Method

}

const options: Request = {
  url:"https.baidu.com",
  methods:"POST"
}

### 类型缩小
Type Narrowing

typeof padding === "number" 可以称之为类型保护 typeGuards

常见的有：
typeof
平等缩小 比如===，！==
instanceof判断是否是某个类的实例
in表示在某个对象里边

1.
type IDType = number | string 
function printID(id:IDType){
  if(typeof id === 'string'){
    console.log(id.toUpperCase())
  }else{
    console.log(id)//typeof帮助我们进行的类型缩小
  }
}


2.平等的类型缩小( === == !== =! switch)
type Direction = "left" | "right" | "top" | "bottom"
function printDirection(direction:Direction){
  if(direction === "left"){

  }else if{

  }
}
switch(direction){
  case 'left':
   console.log(direction)
   break
  case 'right':
   console.log(direction)
   ...
}

3.instanceof
function printTIme(time:tring | Date){
  if(time instanceof Date){
    console.log(time.toUTCString())
  }else{
    console.log(time)
  }
}


class Student {
  studying(){}
}
class Teacher{
  teaching(){}
}
function work(p:Student|Teacher){
  if(p instanceof Student){
    p.studying()
  }else{
    p.teaching()
  }
}


4.in
type Fish = {swiming: () => void}//函数类型
type Dog = {running:() => void}
function sport(animal:Fish|Dog){
  if('swimming' in animal){
    animal.swimming()
  }else{
    animal.running()
  }
}
const fish:Fish = {
  swimming(){
    console.log("swimming")
  }
}

sport(fish)


## TypeScript函数类型
anotation 注释
type Footype = () => void
function foo(){

}

function bar(fn:Footype){
//:后面的就是函数类型的表示
}

bar(foo)
当一个函数的参数是另一个函数的时候就需要用到函数类型


### 定义常量时编写函数的类型
type AddFnType =  (num1:number,num2:number) => number///void可以返回任何值 
const add: AddFnType= (num1:number,num2:number) =>{

}

const tuple:[number,(numberNum:number) => void] = [123]
元组型也需要将传的参数进行参数的定义


### 函数类型的案例：
function calculate(n1:number,n2:number,fn:(num1:number,num2:number) =>number){
  return fn(n1,n2)
}
calculate(20,30,function(a1,a2){
  return a1+a2
})
calculate(20,30,function(a1,a2){
  return a1*a2
})

### 函数的可选类型
可选类型必须写在必选类型之后,？ 相当于 undefined | number ，如果写成这个就必须传入undefined
function foo(x:number,y?:number){

}
foo(20,30)

### 参数的默认值
function foo(x:number,y:number = 100){

}
foo(200)什么都不写的时候就会使用默认值
console.log(x,y)


###  函数的剩余参数
console.log(...data:any),括号里的参数会被放到一个数组里边
function sum(...nums:number[]){
  就可以进行多个数的添加
}

### 函数的重载
函数的重载：函数的名称相同，但是参数不同的几个函数，就是函数的重载
例子：编写一个字符串和数字相加的函数

type AddType = number | string
function add(a1:number | string,a2:number | string){
  if()
  return a1 + a2
}
通过以上方法不方便，用函数重载
function add(num1:number,num2:number):number;
function add(num1:string,num2:string):number;
function add(num1:any,num2:any):any{
  if(typeof num1 === 'strng' && typeof num2 === 'string'){
    return num1.length + num2.length
  }
  return num1 + num2
}
const result = add(20,30)
const result = add("abc","cba")
要符合重载函数才能调用实现函数

练习：
1.联合类型
function getLength(args:string | any[]) {
  return args.length
}
console.log(getLength("abac"))//3
console.log(getLength([123,123123,4214]))//3


2.函数重载
function getLength(args:string):number
function getLength(args:any[]):number

function getLength(args:any):number{
  return args.length
}


开发中联合类型实现比较简单




## 类的使用
编程范式
面向对象编程：c++、Java
函数式编程：JavaScript，lisp
类的三大特性，封装，继承，多态

### 类的定义
需要初始化,直接初始化或者在constructor定义constructor(name:string,age:number){this.name = name,this.age = age}
name:string = ""
age:number = 0
class Person {
  name:string = ""
  age:number = 0
  eating(){
    console.log(this.name + "eating")
  }
}

const p = new Person("xx",18)
console.log(p.name)
console.log(p.age)
p.eating()
export{}

### 类的继承
将共同拥有的属性放到一个公共的类里面，继承是多态的前提
Student extends Person
Teacher extends Person

子类调用父类构造方法
用super调用父类构造器
super(name,age),调用父类的构造器构造name,age，构造的话必须先构造实例才能用this
super.eating()如果想实行子类里面的eating又想执行父类的eating ，可以使用
这样子就会实现子类和父类的eating都实现

### 类的多态
class Animal{
  action(){
    console.log("action")
  }
}

class Dog extends Animal{
  action(){
    console.log("dog")
  }
}

class Fish extends Animal{
  action(){
    console.log("fish")
  }
}

function makeActions(animal:Animal[]){
  animal.forEach( item =>{
    item.action()
  })
}


makeActions([new Dog(),new Fish])
通过以上代码就是多态，实现了dog和fish
父类引用指向子类对象
多态的目的是写出更具备通用性的代码

### 类成员的修饰符
public，private，protected

class Person{
  public name:string =""
}
public是公开的，private表示当前类才能访问，在类的内部才可以使用，
protected表示类内部和子类可以访问

class Person{
  private name:string =""
  getName(){
    return this.name
  }
  setName(){
    this.name = newname
  }
}
const p = new Person()
p.setName("why")//通过这样可以修改


### readonly只读属性
1.可以在构造器里面赋值，但是赋值以后不可以修改
2.属性本身不可以修改，但是如果它是对象类型，对象中的属性是可以修改的

class Person{
  readonly name:string =""
  constructor(name:string){
    this.name = name
  }
  getName(){
    return this.name
  }
  setName(){
    this.name = newname
  }
}

const p = new Person("why",new Persom("kobe"))
console.log(p.name)
p.name = "123"


### getters和setters属性
一般是以下划线开头表示私有属性,
getters和setters类似于访问器，可以直接从类里面拿值，用对象的方法那
class Person {
  provate _name:string
  consctructor(name:string){
    this.name = name
  }
  set name(newname){
    this._name = newName
  }
  get name(){
    return this._name
  }
}

const p = new Person("xixi")
p.name = "haha"
console.log(p.name)

### 类的静态成员
class Person {
  name:string = ""
  age:number = 12
}

const p = new Person()
p.name = "123"

class Student {
  static time:string = "20:00"
}

console.log(Student.time)//就可以不用实例直接取数，可以用类名直接访问

### 抽象类abstract

function makeArea(shape:Shape){
  return shape.getArea()
}
abstract class Shape{
  abstract getArea()
}
抽象类的方法必须被实现，且需要抽象类里面使用抽象方法，如果有不是抽象方法可以不用加abstract
抽象类不能被实例化，如果不实现的话子类也需要变成抽象类


### 类的类型
class Person{
  name:string = "133"
}
const p1:Person = {
  name :why
}


## interface接口声明
1.别名声明对象
type InfoType = {name:string,age:number}

2.接口声明对象
interface IInfoType = {
  name:string
  age:number
}
加一个I表示接口
跟type差不多，也有readonly那些



### 索引类型
const frontLanguage:IndexLanguage = {
  0:"htlm",
  1:"css",
  2:"JavaScript",
  3:"Vue"
}


可以用interface来定义索引类型
interface IndexLanguage {
  [index:number] : string//index就是索引
}


### 函数类型interface

function calculate(n1:number,n2:number,fn:(num1:number,num2:number) =>number){
  return fn(n1,n2)
}
calculate(20,30,function(a1,a2){
  return a1+a2
})
calculate(20,30,function(a1,a2){
  return a1*a2
})


### 接口的继承
### 交叉类型
### 接口的实现
interface ISwim {
  swimming :() => void
}

interface IEat {
  eating() => void
}

//传入一个函数
const a:ISwim = {
  swimming(){}
}

//传入对象
function foo(swim:ISwim) {

}


继承只可以是单继承
实现接口继承，类可以实现多个接口,如果使用了继承就必须实现对应的方法，实现对应的接口
例子：
class Fish extends Animal implements IsSwim,IsEat {
  swimming(){

  }
  eating(){

  }
}

面向接口编程：
function swimAction(swimable:ISwim){
  swimable.swimming()
}
//implements实施，实现接口，lib库
class Person implements ISwim{
  swimming(){

  }
}
所有实现接口的对象都可以传入

### interface和type区别
如果是定义非对象类型，通常推荐使用type
如果是定义对象类型的区别：
interface可以重复对某个接口来定义属性和方法；
type定义的是别名，别名不能重复,下述即使表达interface和type的区别

例：
interface Ifoo{
  name:string
}
interface Ifoo{
  age:number
}

const foo :Ifoo = {
  name:"xixi",
  age:11
}
两个相同属性名称就会合并


interface定义接口的时候就可以与原有的合并
interface Window {
  age:number
}

window.age = 19
console.log(window.age)



### 字面量赋值
先将一个属性赋给一个info，后面将address加上且赋值给定义的对象，他也会进行类型推导，推导出来就是一个对象类型INFO里面，相当于是对对象的引用赋值到P。
freshness擦除，当info赋值给p的时候会，类型检测的时候去除掉多余的属性

使用方法：将要传的参数，赋值给一个对象，然后传入对象就可以避开多余属性的检测，但是默认不可以通过person.address获取到值

使用场景，有时候传的值有很多属性，但是我们只需要用到几个，这样子我们就可以用这个让我们的使用更加灵活

interface IPserson {
  name:string
  age:number
  height:number
}
const info = {
  name:"xxx"
  age:12
  height:23
  address:"xian"
}
const p:IPerson = info



### TypeScript枚举类型（特有）
就是将可能出现的值一个个列举出来，穷举，允许开发者定义一组数字也可以是字符串类型。
使用方式：
enum 用来定义枚举的，也是一个关键字
enum Direction {
  LEFT = 100,
  RIGHT,
  TOP,
  BOTTOM
}
//以上的本质是一个常量0123，也可以改变他们的值，

function turnDirection(direction:Direction){
  swich(direction) {
    case Direction.LEFT:
    console.log("向左")
    break
    ......
    default:
    const foo :never = direction;
    break;//never的使用，若没有举例完就会报错
  }
}

turnDirection(Direction.LEFT),用于监听各个方法

export{}


## 泛型
为了让代码有更强的可复用性和易用性
### 泛型的使用
function sum(num1:number,num2:number,num3?:any[]){//参数的类型不固定就可以传入更多
  return num1 + num2
}
sum({},{})
sum([],[])
sun(23,23)

为了解决上述问题
类型参数化，定义参数的时候不决定参数的类型，而是让调用者告诉我是什么类型
1.明确传入类型
function sum<Type>(num1:Type):Type{
  return num1
}

sum<number>(20)
sum<any[]> (["abc"])
sum<{name:string}>({name:"why"})

2.类型推导
sum(50)/类型推导就是字面量类型

### 泛型参数
可以有多个参数
function foo<T,E>(arg1:T,arg2:E,...args:T[]){//...args后面传入的参数都只能是T
    
}
foo<number,string>(10,"23dv")

T：tyoe
K:key,value
E:elment
O:object


### 泛型接口
interface IPerson<T1 = string,T2 = number> {
  name:T1
  age:T2
}

const p:Iperson<string,number> = {
  name:"why",
  age:18
}

在后边决定IPerson的类型,也可以传入默认类型如上

### 泛型类的使用
class Point<T>{
  x:T
  y:T
  z:T
}

constructor(x:T,y:T,z:T){
  this.x = x
  this.y = y
  this.z = z
}

const p1 = new Point("")
const p2 = new Point<string>("")
const p3:Point(string) = new Point("")

const names:string[] = [""]
const names:Array<string> = [""]//不推荐

### 泛型的类型约束
给泛型一个约束，这样子就只能传有Length的类型
interface Ilength {
  length:number
}

function getLength<T extends Ilength>(arg:T){
  return arg.length
}
getLength([""])
getLength()
getLength{length：}

## TypeScript其他内容补充
### 模块化开发
TypeScript支持ES module，也支持CommonJS，跟js的模块化开发差不多


### 命名空间作用域

通过namespace来声明一个命名空间，也叫内部模块
在src/utils里面封装一些功能，add，sub，format时间
namespace time{
export function format(time:string){
  return "2200-22-22"
export function foo(){

}
}
}
namespace price{
export function format(price:number){
  return 99
}
}
要用的时候:
time.format
time.price
time.foo
命名空间就是在导出的地方使用命名空间加名字


### declare声明
第三方库使用
import axios form 'axios'

axios.get("https://hao123.com").then(res => {
  console.log(res)
})

导入lodash就会报错,因为没有声明
import _ form 'lodash'

### 类型查找
.d.ts文件用于做类型声明.d.ts告诉TypeScript有哪些类型
1.内置类型声明；math，data，window，document安装好自带的
https://github.com/microsoft/TypeScript/tree/main/lib



2.外部定义类型声明：方式一：自己编写.d.ts比如axios 
方式二：通过社区一个公有库DefinitelyTyped存放类型声明文件。
该库的GitHub地址：https://github.com/DefinitelyTyped/DefinitelyTyped/
该库查找声明安装方式的地址：https://www.typescriptlang.org/dt/search?search=
比如我们安装react的类型声明： npm i @types/react --save-dev



3.自定义类型声明：
lodash.d.ts
declare module 'lodash'{
  export function join(arr:any[]):void
}

console.log(ladash.join(["abc","cba"]))


通过声明告诉TypeScript有这个类型就不会报错了，只是声明就行了不用赋值，它会自动找到相对应的值
也可以声明函数，类，变量
declare let whyName:string

constructor//构造器

声明文件
声明.jsp结尾的是一个模块可以使用
declare module '*.jpg'///jpeg/png/gif/svg/

.vue文件声明
declare module '*.vue' {
  import { DefineComponent } 
}


声明命名空间
导入jQuery的时候
declare namespace $ {
  export function ajax(settings:any):any
}

这样子就可以用$.ajax

# 项目开发
## 项目搭建
通过配置各种东西达到更加规范的目的

## 区分不同环境
开发环境：development  base_URL = "/dev"
生产环境：production   base_URL = "/pro"
测试环境：test         base_URL = "/test"


环境的切换
使用process.env.NODE_ENV === 'production/development/test'


新建的.env文件里面可以写入环境变量，


### 封装axios
拦截器：携带token和设置loading动画

用TypeScript封装，封装思路：用Class将全部的axios要封装的封装到一起，然后通过constructor构造实例对象，可以用interface给Class类添加别的属性，然后导出进行使用，loading动画效果用element-plus设置动画效果，当请求的时候可以设置，然后需要关闭

有空的时候封装试试



## 项目初始化

npm install normalize.css

样式初始化，



## 项目登录

首页登录框用element-plus选择两个，手机登录以及账号登录

两个逻辑不一致

分开写，账号登陆，手机登录创建两个文件

账号登陆逻辑：

form

form-item

input

验证逻辑：

const rules =  {

name:[{必传required:true,message:'请输入正确的账号',trigger:'blur'触发条件},{pattern:/^[a-zo-9/{5,10}$]

,message:'用户名必须是5-10个字母或者数字'},

password:[],和上面写法类似

定义完返回rules，然后：rules绑定到el-form里面 还有绑定：model = “account”，告诉form传的值

在el-form-item 绑定prop = “name”/password

可以将这个抽出到一个配置文件里面，因为是固定的不需要抽取到一个hook里面，然后需要return出去

记住密码用checkbox，忘记密码用一个link，

立即登录

用一个button需要绑定账号密码并且提交，要拿到账号密码，验证

用ref绑定用=“formRef”。valid验证是否符合正则，才可以相应登录按钮，登录逻辑在各自的子组件进行验证

用vuex使用TypeScript

### 记住密码逻辑

应用localstorage，记录本地缓存，然后可以用json记住传来的东西全部转化为字符串，下次登录就把那个变为原来存的值 ？？



### 知识补充

每一个组件的引用都是新建的一个组件实例，类似于class

确定引入类型

<InstanceType<typeof Demo>>

instance实例，表示的是实例类型为Demo的对象类型

快速转类型的方法json to ts ，这样就可以快速转换类型

存储登录的token，防止用户刷新，登陆界面与其他界面跳转逻辑

登录逻辑划分完成



### 首页布局

1.用element-plus然后用flex布局

在template寻找路径的时候需要用src=“~@/路径”

遍历最好用template配合v-for进行遍历，

添加动态路由





### webpack require用法获取路径

cont routerfile = require.context('路径',true,/\\.ts/)

routerfile.keys().forEach((key) =>{})

 指的是在路径中递归扫描。ts文件





### es6 find函数

通过。find可以找到相对应的某一个



## 动态路由

3中方法

1.根据用户固定界面，缺点：不是太好，容易每次有新的用户需要重新打包部署

2.直接全部写上，根据用户显示不同的页面

3.根据角色，给不用的角色分配不同得权限，然后不同的角色显示不同的界面，然后进行分配

## 高级组件封装

为了更加适用于自己的开发，在ui组件库的基础上进行封装





### 注意事项

关于刷新跳转问题，在main使用vuex和router的时候需进行提前映射路径再使用路由，防止路由取不到值返回错误界面



面包屑的设计，需通过类似点击选项确定name，然后绑定到相关的东西上



### table

通用得东西可以配合table得element-plus进行封装达到更好的效果，然后获取后端数据遍历动态生成表格





### 作用域和动态插槽

通过作用域插槽可以，指定某一项数据得改变，太妙了





18



### 全局工具的使用

$filters是里面的一个属性，使用的时候直接$filters.formatTime()，就可以实现调用

在main.ts 里面app.config.globalProperties.$filters = {

foo(){

},

formatTime(value:string){

 return格式时间

}

}

可以将上述全局注册添加到global里面，然后通过app.use(globalRegister)





export fuction globalRegister(app:App):void {

​    app.use(registerElement)

​	app.use(registerProperties)

}



### 文件命名注意事项

一般经常使用的工具封装在utils文件价

全局注册封装在global

组件可封装在components

路由放在router里面

vuex放在store里边

网络请求服务放在service里边

界面的搭建放在views里面

取消es-link检测的放在es-linktrc里面

某些库引用的时候不会被ts识别，就通过.d.ts文件进行声明

.browserslistrc文件是用于浏览器适配配置的



### 时间格式化

＇＇＇　

const DATE＿ＴＩＭＥ_ＦＯＲＭＡＴ　＝‘YYYY－MM-DD　HH：ｍｍ：ｓｓ‘

export　function　formatＵｔｃＳｔｒｉｎｇ（ｕｔｃｓｔｒｉｎｇ：ｓｔｒｉｎｇ，ｆｏｒｍａｔ：ｓｔｒｉｎｇ＝DATE＿ＴＩＭＥ_ＦＯＲＭＡＴ）｛

　ｒｅｔｕｒｎ　ｄａｙｊｓ．ｕｔｃ（ｕｔｃｓｔｒｉｎｇ）．ｆｏｒｍａｔ（ｆｏｒｍａｔ）

｝

＇＇＇

ｎｐｍ　　install　ｄａｔｊｓ

import　ｕｔｃ　form　“ｄａｔｊｓ／ｐｌｕｇｉｎ／ｕｔｃ”

ｄａｙｊｓ．ｅｘｔｅｎｄ（ｅｔｃ）





### 是否显示数字标志

el-tabel-column v-fi type = "" label = "序号"

封装到table，用v-if 决定是否显示

然后通过user界面决定是否调用

### 选中按钮

也是通过设置一个Boolean类型的值，就可以控制是否显示可选框，并且设置一个全选按钮

传到hy-table，然后通过props然后在table.vue，用v-if，type:selection

选中了之后会在el-table触发@selection-change=“handlechange”



setup(){

const handlechange = (value=any) => {

   //到时候回回传一个value，是一个proxy对象可以对你选中的数据进行操作

} 

}

### 子组件发数据给父组件

emits:['handlechange'],

setup(props,{ emit }){

 const handlechange

​	emit('handlechange',value)

}

### 最右边操作栏

删除和编辑

通过插槽，不需要作用域插槽不用绑定数据，绑定到user界面里面，也可以对按钮进行相对应的样式的调整，type：text，el-icon 图标，

### 分页

header用户列表和新建用户

footer分页器



### 商品列表

用el-image，封装到page里面，然后通过配置生成我们所需要的新的界面

el-cloum设置文字长短限制以及鼠标悬停显示文本









底部的分页可以通过设置一个footer来设置，可以设置一个标志位来到时候展示是否显示



### 权限管理

！！双叹号可以将表达式转化为Boolean类型

用户按钮权限管理，通过给编辑新建用户和删除都绑定上v-if

然后



### 编辑删除按钮

获取点击删除的按钮的url，然后调用删除网络请求，最后重新获取最新数据dispatch

page-content-》vuex-》service

### 新建用户

点击新建和编辑都弹出，编辑需要回显所点击的那个

setup里面可以接受props的值，然后通过props.name用

点击编辑回显原来的信息，通过watch绑定 

某一项不显示可以通过给el-form添加一个属性进行配置

例如用户密码，然后可以设置isshow的值来显示是否显示

![image-20211203104955359](你好       桃子.assets/image-20211203104955359.png)

通过此拿到password项然后设置成false，！就是表示确定有哪个数

想要实时更新数据需要服务器主动告诉客户端，用socket，即是即时通讯，以前用轮询



新建的用户单独保留更好

![image-20211203111752548](你好       桃子.assets/image-20211203111752548.png)

选择部门和角色，需要通过动态获取数据

vuex数据刷新有时候需要放到computed里面为了动态展示，防止刷新拿不到数据

### 确定按钮的点击

发送post请求发送到服务器



### 编辑按钮的请求

获取当前id的选项的值，发送patch请求

### 时间的调整

![image-20211204181154256](你好       桃子.assets/image-20211204181154256.png)

通过utcoffset偏移

### 退出登录功能

1.删除token

![image-20211204182036758](你好       桃子.assets/image-20211204182036758.png)

跳到首页或者登录页，跳转到首页的时候需要用守卫

2.若服务器有存储东西的时候就告诉服务器当前登录用户的数据





### 登录逻辑

![image-20211204182611147](你好       桃子.assets/image-20211204182611147.png)

为防止登录出错出现bug，需要通过以上语句进行调用根的dispatch，模块里面调用根的action

初始化数据请求



### 新建角色

主要获得权限，获取菜单列表

### 编辑角色

需要回显编辑角色所拥有的权限，在pagecontent里面可以拿到里面的权限，

nextTick下一帧再做操作

### 商品统计

## 数据可视化Echarts

基于JavaScript的开源的图表库

2018 apache的一个孵化项目于今年成为顶级项目

Echarts5今年1月28日发布特点

![image-20211205100148196](你好       桃子.assets/image-20211205100148196.png)

1.使用方法下载安装包导入 npm下载，cdn引入

2.import * as echarts from 'echarts'

3.初始化Echarts对象

echarts.init(dom,theme,options)初始化

通过setOption方法绘制数据

![image-20211205101038117](你好       桃子.assets/image-20211205101038117.png)

一个是在jQuery用一个是vue中使用，都是获取dom节点绑定到echarts.init里面进行初始化

![image-20211205101540445](你好       桃子.assets/image-20211205101540445.png)

vue里面获取对象

setup的时候还没绑定到div里边，所以一般要用oncreate进行初始化

![image-20211205102021314](你好       桃子.assets/image-20211205102021314.png)

vue3实际使用

theme主题：light默认主题，dark

![image-20211205141835173](你好       桃子.assets/image-20211205141835173.png)

可以在第二个参数设置主题，第三个是其他的option，一般传渲染器renderer：‘svg’、canvas两个渲染器

当绘制的数据非常大用canvas更好，但是大部分场景下svg更具备优势，占据内存更低渲染性能更高

fps frame per second

## vue scriptsetup使用注意事项

使用script lang="ts" setup 

更新vue最新版本的时候，最好也更新一下，@vue/compiler-sfc,他是lodash的编译器，这样更好适配代码

## defineProps和withDefaults

![image-20211206123501267](你好       桃子.assets/image-20211206123501267.png)

在ts里面传参数用defineProps，withDefaults是用于传默认值

![image-20211206123705475](你好       桃子.assets/image-20211206123705475.png)

调用完那两个函数之后回返回一个props，在props里面就可以拿到我们的width和height，跟原来的js那props不太一样，这个是调用defineProps函数进行调用的

### 垃圾回收机制garbage collection

引用计数，

标记清除
